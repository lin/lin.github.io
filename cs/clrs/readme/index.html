<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>- Yingkui</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Yingkui"><meta itemprop=description content="Time Complexity minHeap Operation Big-O Notes Insert O(log n) 1. insert at last; 2, heapifyUp Remove O(log n) 1. swap first and last; 2, heapifyDown buildHeap O(n) from parent(last) to 1, heapifyDown heap sort O(n log n) 1.build need n, 2, removeMin need lg n Array and List Operation Array Linked List InsertFront O(1)* O(1) InsertAfter O(n) O(1) RemoveAfter O(n) O(1) Find O(n) O(n) Access O(1) O(n) Stack and Queue Everything (create, push, pop, empty) is O(1) or O(1)*"><meta itemprop=wordCount content="241"><meta property="og:url" content="https://yingkui.com/cs/clrs/readme/"><meta property="og:site_name" content="Yingkui"><meta property="og:title" content="Yingkui"><meta property="og:description" content="Time Complexity minHeap Operation Big-O Notes Insert O(log n) 1. insert at last; 2, heapifyUp Remove O(log n) 1. swap first and last; 2, heapifyDown buildHeap O(n) from parent(last) to 1, heapifyDown heap sort O(n log n) 1.build need n, 2, removeMin need lg n Array and List Operation Array Linked List InsertFront O(1)* O(1) InsertAfter O(n) O(1) RemoveAfter O(n) O(1) Find O(n) O(n) Access O(1) O(n) Stack and Queue Everything (create, push, pop, empty) is O(1) or O(1)*"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="cs"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Time Complexity minHeap Operation Big-O Notes Insert O(log n) 1. insert at last; 2, heapifyUp Remove O(log n) 1. swap first and last; 2, heapifyDown buildHeap O(n) from parent(last) to 1, heapifyDown heap sort O(n log n) 1.build need n, 2, removeMin need lg n Array and List Operation Array Linked List InsertFront O(1)* O(1) InsertAfter O(n) O(1) RemoveAfter O(n) O(1) Find O(n) O(n) Access O(1) O(n) Stack and Queue Everything (create, push, pop, empty) is O(1) or O(1)*"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yingkui.com/css/dark.css><link rel=stylesheet type=text/css href=https://yingkui.com/css/custom.css><script src=https://yingkui.com/js/feather.min.js></script><script src=https://yingkui.com/js/main.js></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://yingkui.com/><img src=/logo-ai.jpg alt=Yingkui></a></div><h1 class=site-title><a href=https://yingkui.com/>Yingkui</a></h1><div class=site-description><p>Solving Problems. Making Progress.</p><nav class="nav social"><ul class=flat><li><a href=https://github.com/lin title=Github><i data-feather=github></i></a></li><li><a href=https://youtube.com/@yingkui title=YouTube><i data-feather=youtube></i></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>随想</a></li><li><a href=/edu>《教学》</a></li><li><a href=/life>《人生》</a></li><li><a href=/ai>《智力》</a></li><li><a href=/about>关于</a></li></ul></nav></div><div class=post><div class=post-header><div class=matter><h1 class=title></h1></div></div><div class=markdown><h1 id=time-complexity>Time Complexity</h1><h3 id=minheap>minHeap</h3><table><thead><tr><th>Operation</th><th style=text-align:center>Big-O</th><th style=text-align:left>Notes</th></tr></thead><tbody><tr><td>Insert</td><td style=text-align:center>O(log n)</td><td style=text-align:left>1. insert at last; 2, heapifyUp</td></tr><tr><td>Remove</td><td style=text-align:center>O(log n)</td><td style=text-align:left>1. swap first and last; 2, heapifyDown</td></tr><tr><td>buildHeap</td><td style=text-align:center>O(n)</td><td style=text-align:left>from parent(last) to 1, heapifyDown</td></tr><tr><td>heap sort</td><td style=text-align:center>O(n log n)</td><td style=text-align:left>1.build need n, 2, removeMin need lg n</td></tr></tbody></table><h3 id=array-and-list>Array and List</h3><table><thead><tr><th>Operation</th><th style=text-align:center>Array</th><th style=text-align:center>Linked List</th></tr></thead><tbody><tr><td>InsertFront</td><td style=text-align:center>O(1)*</td><td style=text-align:center>O(1)</td></tr><tr><td>InsertAfter</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(1)</td></tr><tr><td>RemoveAfter</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(1)</td></tr><tr><td>Find</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(n)</td></tr><tr><td>Access</td><td style=text-align:center>O(1)</td><td style=text-align:center>O(n)</td></tr></tbody></table><h3 id=stack-and-queue>Stack and Queue</h3><p>Everything (create, push, pop, empty) is O(1) or O(1)*</p><h3 id=hash>Hash</h3><table><thead><tr><th>Operation</th><th style=text-align:center>Separate Chaining</th><th style=text-align:center>Double Hashing</th></tr></thead><tbody><tr><td>Insert(worst)</td><td style=text-align:center>O(1)</td><td style=text-align:center></td></tr><tr><td>Insert(SUHA)</td><td style=text-align:center>O(1)</td><td style=text-align:center>~O(1/(1- a))</td></tr><tr><td>Find/Remove(worst)</td><td style=text-align:center>O(n)</td><td style=text-align:center></td></tr><tr><td>Find/Remove(SUHA)</td><td style=text-align:center>O(a)</td><td style=text-align:center>~O(1/(1- a))</td></tr></tbody></table><h3 id=binary-search-tree>Binary Search Tree</h3><table><thead><tr><th>Operation</th><th style=text-align:center>BST (average / AVL)</th><th style=text-align:center>BST (worst)</th><th style=text-align:center>Sorted Array</th><th style=text-align:center>Sorted List</th></tr></thead><tbody><tr><td>Find</td><td style=text-align:center>O(lg n)</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(lg n)</td><td style=text-align:center>O(n)</td></tr><tr><td>Insert</td><td style=text-align:center>O(lg n)</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(n)</td></tr><tr><td>Remove</td><td style=text-align:center>O(lg n)</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(n)</td></tr></tbody></table><h3 id=b-tree>B-Tree</h3><table><thead><tr><th>Operation</th><th style=text-align:center>B-Tree</th></tr></thead><tbody><tr><td>Search</td><td style=text-align:center>O( m log_m n )</td></tr></tbody></table><h3 id=disjoint-set>Disjoint Set</h3><table><thead><tr><th>Operation</th><th style=text-align:center>Disjoint Set</th></tr></thead><tbody><tr><td>Find (worst)</td><td style=text-align:center>O(n)</td></tr><tr><td>Find (smart union)</td><td style=text-align:center>O(log n)</td></tr><tr><td>Find (path compression)</td><td style=text-align:center>O(log* n)</td></tr></tbody></table><h3 id=graph-representation>Graph Representation</h3><table><thead><tr><th>Operation</th><th style=text-align:center>Edge List</th><th style=text-align:center>Adj. Matrix</th><th style=text-align:center>Adjacent List</th></tr></thead><tbody><tr><td>Space</td><td style=text-align:center>O(n + m)</td><td style=text-align:center>O(n^2)</td><td style=text-align:center>O(n + m)</td></tr><tr><td>InsertV</td><td style=text-align:center>O(1)*</td><td style=text-align:center>O(n)</td><td style=text-align:center>O(1)*</td></tr><tr><td>RemoveV</td><td style=text-align:center>O(m)</td><td style=text-align:center>O(n)</td><td style=text-align:center>O( deg(v) )</td></tr><tr><td>InsertE</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td>RemoveE</td><td style=text-align:center>1</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td>getNeighbors</td><td style=text-align:center>O(m)</td><td style=text-align:center>O(n)</td><td style=text-align:center>O( deg(v) )</td></tr><tr><td>isAdjacent</td><td style=text-align:center>O(m)</td><td style=text-align:center>O(1)</td><td style=text-align:center>O( min deg(v) )</td></tr></tbody></table><h3 id=graph-algorithms>Graph Algorithms</h3><table><thead><tr><th>Operation</th><th style=text-align:center>Complexity</th></tr></thead><tbody><tr><td>BFS</td><td style=text-align:center>O(n + m)</td></tr><tr><td>DFS</td><td style=text-align:center>O(n + m)</td></tr><tr><td>MST-Kruskal (minHeap & Sored Array)</td><td style=text-align:center>O(m log m)</td></tr><tr><td>MST-Prim (Sparse)</td><td style=text-align:center>O(m log m)</td></tr><tr><td>MST-Prim (Dense)</td><td style=text-align:center>O(n^2 log n)</td></tr><tr><td>SSSP-Dijkstra</td><td style=text-align:center>O(m + n log n)</td></tr></tbody></table></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2024 © Copyright Yingkui.com All Rights Reserved</div></nav></div><script>feather.replace()</script></body></html>