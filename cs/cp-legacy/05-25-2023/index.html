<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>每日刷题总结 - Yingkui Lin</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="每日刷题总结"><meta itemprop=description content="1 - Precomputation: 1. Two Sum Normally, we may use brute force to find the solution.
class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: n = len(nums) for i in range(n): for j in range(i+1, n): if nums[i] + nums[j] == target: return [i, j] But for i after first j, we have seen them and we can remember them while we progress to higher i.
Or we can precompute the position for a seen number"><meta itemprop=datePublished content="2023-05-23T00:00:00+00:00"><meta itemprop=dateModified content="2023-05-23T00:00:00+00:00"><meta itemprop=wordCount content="1129"><meta property="og:url" content="https://yingkui.com/cs/cp-legacy/05-25-2023/"><meta property="og:site_name" content="Yingkui Lin"><meta property="og:title" content="每日刷题总结"><meta property="og:description" content="1 - Precomputation: 1. Two Sum Normally, we may use brute force to find the solution.
class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: n = len(nums) for i in range(n): for j in range(i+1, n): if nums[i] + nums[j] == target: return [i, j] But for i after first j, we have seen them and we can remember them while we progress to higher i.
Or we can precompute the position for a seen number"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="cs"><meta property="article:published_time" content="2023-05-23T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-23T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="每日刷题总结"><meta name=twitter:description content="1 - Precomputation: 1. Two Sum Normally, we may use brute force to find the solution.
class Solution: def twoSum(self, nums: List[int], target: int) -> List[int]: n = len(nums) for i in range(n): for j in range(i+1, n): if nums[i] + nums[j] == target: return [i, j] But for i after first j, we have seen them and we can remember them while we progress to higher i.
Or we can precompute the position for a seen number"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yingkui.com/css/dark.css><link rel=stylesheet type=text/css href=https://yingkui.com/css/custom.css><script src=https://yingkui.com/js/main.js></script><link rel=stylesheet href=https://yingkui.com/css/katex.min.css><script defer src=https://yingkui.com/js/katex.min.js></script><script defer src=https://yingkui.com/js/mhchem.min.js></script><script defer src=https://yingkui.com/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://yingkui.com/><img src=/logo-ai.jpg alt="Yingkui Lin"></a></div><h1 class=site-title><a href=https://yingkui.com/>Yingkui Lin</a></h1><div class=site-description><p>A Curious Mind.</p><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Essays</a></li><li><a href=/single>Pages</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>23</span>
<span class=rest>May 2023</span></div></div><div class=matter><h1 class=title>每日刷题总结</h1></div></div><div class=markdown><h3 id=1---precomputation-1-two-sum>1 - Precomputation: <a href=https://leetcode.com/problems/two-sum/>1. Two Sum</a></h3><p>Normally, we may use brute force to find the solution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>twoSum</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> nums[i] <span style=color:#f92672>+</span> nums[j] <span style=color:#f92672>==</span> target:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> [i, j]
</span></span></code></pre></div><p>But for <code>i</code> after first <code>j</code>, we have seen them and we can remember them while we progress to higher <code>i</code>.</p><p>Or we can precompute the position for a seen number</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>twoSum</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>        seen <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, num <span style=color:#f92672>in</span> enumerate(nums):
</span></span><span style=display:flex><span>            seen[num] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, num <span style=color:#f92672>in</span> enumerate(nums):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> target <span style=color:#f92672>-</span> num <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> seen[target<span style=color:#f92672>-</span>num]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> [i, j]
</span></span></code></pre></div><p>We can improve the above but realize we can do one loop, and only use the seen number so far.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>twoSum</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> List[int]:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        seen <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, num <span style=color:#f92672>in</span> enumerate(nums):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> target <span style=color:#f92672>-</span> num <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>                j <span style=color:#f92672>=</span> seen[target<span style=color:#f92672>-</span>num]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> [i, j]
</span></span><span style=display:flex><span>            seen[num] <span style=color:#f92672>=</span> i
</span></span></code></pre></div><p>To improve time complexity, we wish something we have seen can be used to compute in the future.</p><p>$$
f(a_j) = g(a_1, a_2, \cdots ,a_{j-1})
$$</p><p>And the computation for the past have to be <code>O(1)</code>, if you have to go through the past you are getting an <code>O(N^2)</code> as a result.</p><p>So that means you have a $b_n$, and $b_n = h(b_{n-1})$, or with a small number k, $b_n = h(b_{n-1}, b_{n-2},\cdots,b_{n-k})$</p><p>In this problem, we actually used precomputation techniques. That means we can calculate some properties of the array in advance, something like prefix sum or mono stack. And use it in the future.</p><p>$$
b_i = f(a_i)
$$</p><p>with f is an operation of <code>O(1)</code>. Though we can use one loop to avoid precomputation, a precomputation makes the code easier to read and debug.</p><p>Some precomputation based techniques:</p><ul><li><strong>Prefix Sum</strong> / and / xor / or. $a_i + a_{i+1} + \cdots + a_j = S_{j} - S_{i-1}$</li><li><strong>Mono Stack</strong>, this is not as easy to understand as <em>prefix sum</em>.</li><li><strong>Previous Max</strong>, <strong>Next Max</strong>, <strong>Previous Seen</strong></li><li><strong>Rolling Hash</strong></li></ul><h3 id=2---stack-20-valid-parentheses>2 - Stack: <a href=https://leetcode.com/problems/valid-parentheses/>20. Valid Parentheses</a></h3><p>This problem is a typical push down automata which uses a stack as a helper data structure.</p><p>As in this problem, all we need to remember is the <em>last</em> element and remove its complemetary part.</p><h3 id=3---two-pointers-21-merge-two-sorted-lists>3 - Two Pointers: <a href=https://leetcode.com/problems/merge-two-sorted-lists/>21. Merge Two Sorted Lists</a></h3><p>This is an easier version of <a href=https://leetcode.com/problems/merge-sorted-array/>88. Merge Sorted Array</a>, which uses two pointers to progress the computation.</p><h3 id=4---precomputation-121-best-time-to-buy-and-sell-stock>4 - Precomputation <a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock/>121. Best Time to Buy and Sell Stock</a></h3><p>This problem is basically as same as the two sum. For each price, we want to know the min price before it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>maxProfit</span>(self, prices: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(prices)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, n):
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> max(res, prices[i] <span style=color:#f92672>-</span> min(prices[:i]))
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res
</span></span></code></pre></div><p>The problem we need to solve is to reduce <code>max</code> and <code>min</code> computations, and we can try to precompute the min price before each position i.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>maxProfit</span>(self, prices: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(prices)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        prev_min <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        min_price <span style=color:#f92672>=</span> inf
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, price <span style=color:#f92672>in</span> enumerate(prices):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            prev_min[i] <span style=color:#f92672>=</span> min_price
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> price <span style=color:#f92672>&lt;</span> min_price:
</span></span><span style=display:flex><span>                min_price <span style=color:#f92672>=</span> price
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, price <span style=color:#f92672>in</span> enumerate(prices):
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> max(res, price <span style=color:#f92672>-</span> prev_min[i])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res
</span></span></code></pre></div><p>Or we can use the fact <code>min([a,b,c]) === min([min([a,b]), c])</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>maxProfit</span>(self, prices: List[int]) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        n <span style=color:#f92672>=</span> len(prices)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        prev_min <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> n
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        min_price <span style=color:#f92672>=</span> inf
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, price <span style=color:#f92672>in</span> enumerate(prices):
</span></span><span style=display:flex><span>            prev_min[i] <span style=color:#f92672>=</span> min_price
</span></span><span style=display:flex><span>            min_price<span style=color:#f92672>=</span> min(min_price, price)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i, price <span style=color:#f92672>in</span> enumerate(prices):
</span></span><span style=display:flex><span>            res <span style=color:#f92672>=</span> max(res, price <span style=color:#f92672>-</span> prev_min[i])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res
</span></span></code></pre></div><h3 id=5---two-pointers-125-valid-palindrome>5 - Two Pointers <a href=https://leetcode.com/problems/valid-palindrome/>125. Valid Palindrome</a></h3><p>This is quick straightforward except for the <code>isalnum</code> check.</p><h3 id=6---dfs-226-invert-binary-tree>6 - DFS <a href=https://leetcode.com/problems/invert-binary-tree/>226. Invert Binary Tree</a></h3><p>This is the real fun. This is the recursive function that we should analyze and think abstractly. And this is the mathematical induction.</p><p>First we assume we have solved the problem, and we use this assumption as a subproblem to solve the whole problem. And finally just as in DP, we need base cases to kick start the effects.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>invertTree</span>(self, root: Optional[TreeNode]) <span style=color:#f92672>-&gt;</span> Optional[TreeNode]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> root:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> root
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>invertTree(root<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>invertTree(root<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        root<span style=color:#f92672>.</span>left <span style=color:#f92672>=</span> right
</span></span><span style=display:flex><span>        root<span style=color:#f92672>.</span>right <span style=color:#f92672>=</span> left
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> root
</span></span></code></pre></div><h3 id=7---counter-242-valid-anagram>7 - Counter <a href=https://leetcode.com/problems/valid-anagram/>242. Valid Anagram</a></h3><p>Nothing complicated here. Normally, we may try every permutation, which is O(n!).</p><p>But here we only care about the frequecy instead of positions. Sometimes we only care what have be seen in the array (set). So for an array we can get more and more information about it.</p><ul><li>length / max / min</li><li>seen symbols / set</li><li>symbol frequencies / combinations</li><li>symbol positions / permutations</li></ul><h3 id=8---binary-search-704-binary-search>8 - Binary Search <a href=https://leetcode.com/problems/binary-search/>704. Binary Search</a></h3><p>This is an exercise. Binary search is to find the first <code>FFFFFTTTTT</code> true position. There are several things to notice:</p><ul><li><code>FFFFFF</code> has no T in it, but <code>right</code> is pointing to the last index, so you need to check for the last index</li><li><code>left</code> and <code>right</code> always point to the same position. That means left will never be <code>right+1</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search</span>(self, nums: List[int], target: int) <span style=color:#f92672>-&gt;</span> int:
</span></span><span style=display:flex><span>        left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        right <span style=color:#f92672>=</span> len(nums) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>            mid <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> nums[mid] <span style=color:#f92672>&gt;=</span> target:
</span></span><span style=display:flex><span>                right <span style=color:#f92672>=</span> mid
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        print(left, right)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> right <span style=color:#66d9ef>if</span> nums[right] <span style=color:#f92672>==</span> target <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sol <span style=color:#f92672>=</span> Solution()
</span></span><span style=display:flex><span>arr <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>9</span>,<span style=color:#ae81ff>12</span>]
</span></span><span style=display:flex><span>sol<span style=color:#f92672>.</span>search(arr, <span style=color:#ae81ff>19</span>)
</span></span><span style=display:flex><span>sol<span style=color:#f92672>.</span>search(arr, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>sol<span style=color:#f92672>.</span>search(arr, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>sol<span style=color:#f92672>.</span>search(arr, <span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>)
</span></span></code></pre></div><h3 id=8---dfs-110-balanced-binary-tree>8 - DFS <a href=https://leetcode.com/problems/balanced-binary-tree/>110. Balanced Binary Tree</a></h3><p>This is tricy because we have to make sure every node is height-balanced that means we need dfs to go through each node.</p><p>We can first solve a subproblem which is to calculate all the heights for each node. This is basically the same thing we do for two sum, precomputation. Using O(N) to get a property for each element, we then use this property to decide for balanced or not.</p><p>When I start to code one year ago, I tried to use the minimum code to solve this problem, as in DP or mono stack, using one loop to solve this problem. But after I have to solve many more difficult problems, I gain the habits to solve smaller problems first to reduce complexity, unless I have master a subproblem using a much faster submodule.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>isBalanced</span>(self, root: Optional[TreeNode]) <span style=color:#f92672>-&gt;</span> bool:
</span></span><span style=display:flex><span>        heights <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_heights</span>(node):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> node:
</span></span><span style=display:flex><span>                node_height <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                left <span style=color:#f92672>=</span> get_heights(node<span style=color:#f92672>.</span>left)
</span></span><span style=display:flex><span>                right <span style=color:#f92672>=</span> get_heights(node<span style=color:#f92672>.</span>right)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                node_height <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> max(left, right)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            heights[node] <span style=color:#f92672>=</span> node_height
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> heights[node]
</span></span><span style=display:flex><span>        get_heights(root)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>check_balance</span>(node):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> node:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> check_balance(node<span style=color:#f92672>.</span>left) <span style=color:#f92672>and</span> \
</span></span><span style=display:flex><span>                    check_balance(node<span style=color:#f92672>.</span>right) <span style=color:#f92672>and</span> \
</span></span><span style=display:flex><span>                    abs(heights[node<span style=color:#f92672>.</span>left] <span style=color:#f92672>-</span> heights[node<span style=color:#f92672>.</span>right]) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> check_balance(root)
</span></span></code></pre></div></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2025 © Copyright Yingkui.com All Rights Reserved</div></nav></div></body></html>