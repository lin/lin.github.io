<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>- Yingkui Lin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Yingkui Lin"><meta itemprop=description content='Functions for Primes The following functions are normal Python functions that work with prime numbers.
def is_divisible(x, y): return any(x == y * z for z in range(1, x + 1)) def is_prime(x): for z in range(2, x): if is_divisible(x, z): return False return x > 1 def nth_prime_dividing_x(n, x): if n == 0: return 0 primes = [] for y in range(2, x + 1): if is_prime(y) and is_divisible(x, y): primes.append(y) return primes[n-1] if n-1 < len(primes) else None def factorial(n): result = 1 for i in range(2, n + 1): result *= i return result def nth_prime(n): if n == 0: return 0 primes = [] candidate = 2 while len(primes) <= n: if is_prime(candidate): primes.append(candidate) candidate += 1 return primes[n] Functions for Sequences def nth_element_of_x(n, x): """ Example: # Encode [2, 0, 3] → 2^2 * 3^0 * 5^3 = 4 * 1 * 125 = 500 x = 500 nth_element_of_x(0, 500) => 2 nth_element_of_x(1, 500) => 0 nth_element_of_x(2, 500) => 3 """ base = nth_prime_dividing_x(n, x) if base is None or base <= 1: return 0 y = 0 while is_divisible(x, base ** (y + 1)): y += 1 return y def len_of_elements_of_x(x): """ Example: x = 500 # This encodes [2, 0, 3] len_of_elements_of_x(500) => 3 """ y = 0 while True: if nth_prime_dividing_x(y, x) == 0: break y += 1 return y def encode_sequence(seq): result = 1 for i in range(len(seq)): prime = nth_prime(i + 1) exponent = seq[i] result *= prime ** exponent return result def concat(x, y): len_x = len_of_elements_of_x(x) len_y = len_of_elements_of_x(y) combined = [] # Add all elements from x for i in range(len_x): combined.append(nth_element_of_x(i, x)) # Add all elements from y for j in range(len_y): combined.append(nth_element_of_x(j, y)) return encode_sequence(combined) def convert_to_sequence(x): """ Example: convert_to_sequence(3) => 8 (2^3) nth_element_of_x(0, convert_to_sequence(3)) => 3 len_of_elements_of_x(convert_to_sequence(3)) => 1 """ return 2 ** x def parens(x): """ Example: x = encode_sequence([5, 7]) parens(x) encodes [11, 5, 7, 13] """ return concat(concat(convert_to_sequence(11), x), convert_to_sequence(13)) Functions for Sequences def is_variable_of_type(n, x): """ Checks if x is a variable of n-th type, meaning: x = z^n for some prime z ≥ 13 Args: n: positive integer x: Gödel number Returns: True if x is the n-th power of some prime z ≥ 13 """ if n == 0: return False for z in range(13, x + 1): if is_prime(z) and z ** n == x: return True return False def is_variable(x): """ Checks if x is a variable (of any n-th type). Returns: True if there exists n such that is_variable_of_type(n, x) is True. """ for n in range(1, x + 1): if is_variable_of_type(n, x): return True return False def negate_formula(x): """ Negates the formula encoded by x. R(5) is Gödel number for the "¬" symbol. Returns: Gödel encoding of [5] + parens(x) """ return concat(convert_to_sequence(5), parens(x)) def disjunction(x, y): """ Logical disjunction of formulas x and y. R(7) is Gödel code for "∨" Returns: Gödel encoding of parens(x) + [7] + parens(y) """ return concat(concat(parens(x), convert_to_sequence(7)), parens(y)) def generalize(x, y): """ Generalization of formula y with respect to variable x. R(9) is Gödel code for the ∀ quantifier. Returns: Gödel encoding of [x] + [9] + parens(y) """ return concat(concat(convert_to_sequence(x), convert_to_sequence(9)), parens(y)) def prefix_f(n, x): """ Returns the result of prefixing &#39;f&#39; (Gödel code 3) n times before x. nth successor of x """ result = x for _ in range(n): result = concat(convert_to_sequence(3), result) return result def number_sign(n): """ Returns the Gödel number representing the numeral for n. Defined as: prefix_f(n, convert_to_sequence(1)) """ return prefix_f(n, convert_to_sequence(1)) def is_first_type_symbol(x): """ Returns: True if x is of the form: [3, 3, ..., 3] + [m] for valid m. Example: convert_to_sequence(1) = 2^1 = 2 prefix_f(2, convert_to_sequence(1)) = [3, 3] + [1] → encodes: convert_to_sequence(3), convert_to_sequence(3), convert_to_sequence(1) x = prefix_f(2, convert_to_sequence(1)) # ≈ 2^3 * 3^3 * 5^1 = 270 is_first_type_symbol(270) => True # m can also be a variable of type 1 m = 13 # a prime ≥ 13, so x = 13^1 = 13 is a variable of type 1 convert_to_sequence(m) = 2^13 = 8192 prefix_f(1, convert_to_sequence(m)) = convert_to_sequence(3) * 8192 is_first_type_symbol(convert_to_sequence(3) * 8192) => True """ for m in range(1, x + 1): if m != 1 and not is_variable_of_type(1, m): continue for n in range(0, x + 1): if prefix_f(n, convert_to_sequence(m)) == x: return True return False def is_symbol_of_type(n, x): """ Determines whether x is a symbol of the n-th type. - If n == 1: same as is_first_type_symbol(x) - If n > 1: x must equal convert_to_sequence(v) for some v where v is a variable of type n Example: n = 1 x = prefix_f(1, convert_to_sequence(1)) => x = convert_to_sequence(3) * convert_to_sequence(1) is_symbol_of_type(1, x) => True n = 2 v = 13 # 13 is prime ≥ 13 → variable of type 2 if x = 13^2 = 169 x = convert_to_sequence(169) # => 2^169 is_symbol_of_type(2, 2**169) => True """ if n == 1: return is_first_type_symbol(x) for v in range(1, x + 1): if is_variable_of_type(n, v) and convert_to_sequence(v) == x: return True return False is_proof_of def is_inference_from(previous_proof, formula): if not previous_proof: return False last_formula = previous_proof[-1] expected_formula_str = f"S({last_formula})" expected_code = formula_to_code.get(expected_formula_str) return expected_code == formula def is_proof_of(proof_sequence, target_formula): # Validate each line for i, formula in enumerate(proof_sequence): if is_axiom(formula): continue if not is_inference_from(proof_sequence[:i], formula): return False # Check that the proof ends in the target formula return proof_sequence[-1] == target_formula_code R(n) def R(n): def is_even(v): return v % 2 == 0 def is_odd(v): return v % 2 == 1 def greater_than_one(v): return v > 1 def return [is_even, is_odd, greater_than_one][n-1] # R(1)(4) => True, because we choose is_even, and call is_even(4) # R(2)(4) => False, because we choose is_odd, and call is_odd(4) K = [n for n in [1,2,3] if not R(n)(n)] # K => [1, 2] # R(1)(1) => 1 is not even # R(2)(2) => 2 is not odd # R(3)(3) => 3 is greater_than_one def S(n): return n in K # S(1) => True # S(3) => False'><meta itemprop=wordCount content="1000"><meta property="og:url" content="https://yingkui.com/cs/godel/python/"><meta property="og:site_name" content="Yingkui Lin"><meta property="og:title" content="Yingkui Lin"><meta property="og:description" content='Functions for Primes The following functions are normal Python functions that work with prime numbers.
def is_divisible(x, y): return any(x == y * z for z in range(1, x + 1)) def is_prime(x): for z in range(2, x): if is_divisible(x, z): return False return x > 1 def nth_prime_dividing_x(n, x): if n == 0: return 0 primes = [] for y in range(2, x + 1): if is_prime(y) and is_divisible(x, y): primes.append(y) return primes[n-1] if n-1 < len(primes) else None def factorial(n): result = 1 for i in range(2, n + 1): result *= i return result def nth_prime(n): if n == 0: return 0 primes = [] candidate = 2 while len(primes) <= n: if is_prime(candidate): primes.append(candidate) candidate += 1 return primes[n] Functions for Sequences def nth_element_of_x(n, x): """ Example: # Encode [2, 0, 3] → 2^2 * 3^0 * 5^3 = 4 * 1 * 125 = 500 x = 500 nth_element_of_x(0, 500) => 2 nth_element_of_x(1, 500) => 0 nth_element_of_x(2, 500) => 3 """ base = nth_prime_dividing_x(n, x) if base is None or base <= 1: return 0 y = 0 while is_divisible(x, base ** (y + 1)): y += 1 return y def len_of_elements_of_x(x): """ Example: x = 500 # This encodes [2, 0, 3] len_of_elements_of_x(500) => 3 """ y = 0 while True: if nth_prime_dividing_x(y, x) == 0: break y += 1 return y def encode_sequence(seq): result = 1 for i in range(len(seq)): prime = nth_prime(i + 1) exponent = seq[i] result *= prime ** exponent return result def concat(x, y): len_x = len_of_elements_of_x(x) len_y = len_of_elements_of_x(y) combined = [] # Add all elements from x for i in range(len_x): combined.append(nth_element_of_x(i, x)) # Add all elements from y for j in range(len_y): combined.append(nth_element_of_x(j, y)) return encode_sequence(combined) def convert_to_sequence(x): """ Example: convert_to_sequence(3) => 8 (2^3) nth_element_of_x(0, convert_to_sequence(3)) => 3 len_of_elements_of_x(convert_to_sequence(3)) => 1 """ return 2 ** x def parens(x): """ Example: x = encode_sequence([5, 7]) parens(x) encodes [11, 5, 7, 13] """ return concat(concat(convert_to_sequence(11), x), convert_to_sequence(13)) Functions for Sequences def is_variable_of_type(n, x): """ Checks if x is a variable of n-th type, meaning: x = z^n for some prime z ≥ 13 Args: n: positive integer x: Gödel number Returns: True if x is the n-th power of some prime z ≥ 13 """ if n == 0: return False for z in range(13, x + 1): if is_prime(z) and z ** n == x: return True return False def is_variable(x): """ Checks if x is a variable (of any n-th type). Returns: True if there exists n such that is_variable_of_type(n, x) is True. """ for n in range(1, x + 1): if is_variable_of_type(n, x): return True return False def negate_formula(x): """ Negates the formula encoded by x. R(5) is Gödel number for the "¬" symbol. Returns: Gödel encoding of [5] + parens(x) """ return concat(convert_to_sequence(5), parens(x)) def disjunction(x, y): """ Logical disjunction of formulas x and y. R(7) is Gödel code for "∨" Returns: Gödel encoding of parens(x) + [7] + parens(y) """ return concat(concat(parens(x), convert_to_sequence(7)), parens(y)) def generalize(x, y): """ Generalization of formula y with respect to variable x. R(9) is Gödel code for the ∀ quantifier. Returns: Gödel encoding of [x] + [9] + parens(y) """ return concat(concat(convert_to_sequence(x), convert_to_sequence(9)), parens(y)) def prefix_f(n, x): """ Returns the result of prefixing &#39;f&#39; (Gödel code 3) n times before x. nth successor of x """ result = x for _ in range(n): result = concat(convert_to_sequence(3), result) return result def number_sign(n): """ Returns the Gödel number representing the numeral for n. Defined as: prefix_f(n, convert_to_sequence(1)) """ return prefix_f(n, convert_to_sequence(1)) def is_first_type_symbol(x): """ Returns: True if x is of the form: [3, 3, ..., 3] + [m] for valid m. Example: convert_to_sequence(1) = 2^1 = 2 prefix_f(2, convert_to_sequence(1)) = [3, 3] + [1] → encodes: convert_to_sequence(3), convert_to_sequence(3), convert_to_sequence(1) x = prefix_f(2, convert_to_sequence(1)) # ≈ 2^3 * 3^3 * 5^1 = 270 is_first_type_symbol(270) => True # m can also be a variable of type 1 m = 13 # a prime ≥ 13, so x = 13^1 = 13 is a variable of type 1 convert_to_sequence(m) = 2^13 = 8192 prefix_f(1, convert_to_sequence(m)) = convert_to_sequence(3) * 8192 is_first_type_symbol(convert_to_sequence(3) * 8192) => True """ for m in range(1, x + 1): if m != 1 and not is_variable_of_type(1, m): continue for n in range(0, x + 1): if prefix_f(n, convert_to_sequence(m)) == x: return True return False def is_symbol_of_type(n, x): """ Determines whether x is a symbol of the n-th type. - If n == 1: same as is_first_type_symbol(x) - If n > 1: x must equal convert_to_sequence(v) for some v where v is a variable of type n Example: n = 1 x = prefix_f(1, convert_to_sequence(1)) => x = convert_to_sequence(3) * convert_to_sequence(1) is_symbol_of_type(1, x) => True n = 2 v = 13 # 13 is prime ≥ 13 → variable of type 2 if x = 13^2 = 169 x = convert_to_sequence(169) # => 2^169 is_symbol_of_type(2, 2**169) => True """ if n == 1: return is_first_type_symbol(x) for v in range(1, x + 1): if is_variable_of_type(n, v) and convert_to_sequence(v) == x: return True return False is_proof_of def is_inference_from(previous_proof, formula): if not previous_proof: return False last_formula = previous_proof[-1] expected_formula_str = f"S({last_formula})" expected_code = formula_to_code.get(expected_formula_str) return expected_code == formula def is_proof_of(proof_sequence, target_formula): # Validate each line for i, formula in enumerate(proof_sequence): if is_axiom(formula): continue if not is_inference_from(proof_sequence[:i], formula): return False # Check that the proof ends in the target formula return proof_sequence[-1] == target_formula_code R(n) def R(n): def is_even(v): return v % 2 == 0 def is_odd(v): return v % 2 == 1 def greater_than_one(v): return v > 1 def return [is_even, is_odd, greater_than_one][n-1] # R(1)(4) => True, because we choose is_even, and call is_even(4) # R(2)(4) => False, because we choose is_odd, and call is_odd(4) K = [n for n in [1,2,3] if not R(n)(n)] # K => [1, 2] # R(1)(1) => 1 is not even # R(2)(2) => 2 is not odd # R(3)(3) => 3 is greater_than_one def S(n): return n in K # S(1) => True # S(3) => False'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="cs"><meta name=twitter:card content="summary"><meta name=twitter:title content="Yingkui Lin"><meta name=twitter:description content='Functions for Primes The following functions are normal Python functions that work with prime numbers.
def is_divisible(x, y): return any(x == y * z for z in range(1, x + 1)) def is_prime(x): for z in range(2, x): if is_divisible(x, z): return False return x > 1 def nth_prime_dividing_x(n, x): if n == 0: return 0 primes = [] for y in range(2, x + 1): if is_prime(y) and is_divisible(x, y): primes.append(y) return primes[n-1] if n-1 < len(primes) else None def factorial(n): result = 1 for i in range(2, n + 1): result *= i return result def nth_prime(n): if n == 0: return 0 primes = [] candidate = 2 while len(primes) <= n: if is_prime(candidate): primes.append(candidate) candidate += 1 return primes[n] Functions for Sequences def nth_element_of_x(n, x): """ Example: # Encode [2, 0, 3] → 2^2 * 3^0 * 5^3 = 4 * 1 * 125 = 500 x = 500 nth_element_of_x(0, 500) => 2 nth_element_of_x(1, 500) => 0 nth_element_of_x(2, 500) => 3 """ base = nth_prime_dividing_x(n, x) if base is None or base <= 1: return 0 y = 0 while is_divisible(x, base ** (y + 1)): y += 1 return y def len_of_elements_of_x(x): """ Example: x = 500 # This encodes [2, 0, 3] len_of_elements_of_x(500) => 3 """ y = 0 while True: if nth_prime_dividing_x(y, x) == 0: break y += 1 return y def encode_sequence(seq): result = 1 for i in range(len(seq)): prime = nth_prime(i + 1) exponent = seq[i] result *= prime ** exponent return result def concat(x, y): len_x = len_of_elements_of_x(x) len_y = len_of_elements_of_x(y) combined = [] # Add all elements from x for i in range(len_x): combined.append(nth_element_of_x(i, x)) # Add all elements from y for j in range(len_y): combined.append(nth_element_of_x(j, y)) return encode_sequence(combined) def convert_to_sequence(x): """ Example: convert_to_sequence(3) => 8 (2^3) nth_element_of_x(0, convert_to_sequence(3)) => 3 len_of_elements_of_x(convert_to_sequence(3)) => 1 """ return 2 ** x def parens(x): """ Example: x = encode_sequence([5, 7]) parens(x) encodes [11, 5, 7, 13] """ return concat(concat(convert_to_sequence(11), x), convert_to_sequence(13)) Functions for Sequences def is_variable_of_type(n, x): """ Checks if x is a variable of n-th type, meaning: x = z^n for some prime z ≥ 13 Args: n: positive integer x: Gödel number Returns: True if x is the n-th power of some prime z ≥ 13 """ if n == 0: return False for z in range(13, x + 1): if is_prime(z) and z ** n == x: return True return False def is_variable(x): """ Checks if x is a variable (of any n-th type). Returns: True if there exists n such that is_variable_of_type(n, x) is True. """ for n in range(1, x + 1): if is_variable_of_type(n, x): return True return False def negate_formula(x): """ Negates the formula encoded by x. R(5) is Gödel number for the "¬" symbol. Returns: Gödel encoding of [5] + parens(x) """ return concat(convert_to_sequence(5), parens(x)) def disjunction(x, y): """ Logical disjunction of formulas x and y. R(7) is Gödel code for "∨" Returns: Gödel encoding of parens(x) + [7] + parens(y) """ return concat(concat(parens(x), convert_to_sequence(7)), parens(y)) def generalize(x, y): """ Generalization of formula y with respect to variable x. R(9) is Gödel code for the ∀ quantifier. Returns: Gödel encoding of [x] + [9] + parens(y) """ return concat(concat(convert_to_sequence(x), convert_to_sequence(9)), parens(y)) def prefix_f(n, x): """ Returns the result of prefixing &#39;f&#39; (Gödel code 3) n times before x. nth successor of x """ result = x for _ in range(n): result = concat(convert_to_sequence(3), result) return result def number_sign(n): """ Returns the Gödel number representing the numeral for n. Defined as: prefix_f(n, convert_to_sequence(1)) """ return prefix_f(n, convert_to_sequence(1)) def is_first_type_symbol(x): """ Returns: True if x is of the form: [3, 3, ..., 3] + [m] for valid m. Example: convert_to_sequence(1) = 2^1 = 2 prefix_f(2, convert_to_sequence(1)) = [3, 3] + [1] → encodes: convert_to_sequence(3), convert_to_sequence(3), convert_to_sequence(1) x = prefix_f(2, convert_to_sequence(1)) # ≈ 2^3 * 3^3 * 5^1 = 270 is_first_type_symbol(270) => True # m can also be a variable of type 1 m = 13 # a prime ≥ 13, so x = 13^1 = 13 is a variable of type 1 convert_to_sequence(m) = 2^13 = 8192 prefix_f(1, convert_to_sequence(m)) = convert_to_sequence(3) * 8192 is_first_type_symbol(convert_to_sequence(3) * 8192) => True """ for m in range(1, x + 1): if m != 1 and not is_variable_of_type(1, m): continue for n in range(0, x + 1): if prefix_f(n, convert_to_sequence(m)) == x: return True return False def is_symbol_of_type(n, x): """ Determines whether x is a symbol of the n-th type. - If n == 1: same as is_first_type_symbol(x) - If n > 1: x must equal convert_to_sequence(v) for some v where v is a variable of type n Example: n = 1 x = prefix_f(1, convert_to_sequence(1)) => x = convert_to_sequence(3) * convert_to_sequence(1) is_symbol_of_type(1, x) => True n = 2 v = 13 # 13 is prime ≥ 13 → variable of type 2 if x = 13^2 = 169 x = convert_to_sequence(169) # => 2^169 is_symbol_of_type(2, 2**169) => True """ if n == 1: return is_first_type_symbol(x) for v in range(1, x + 1): if is_variable_of_type(n, v) and convert_to_sequence(v) == x: return True return False is_proof_of def is_inference_from(previous_proof, formula): if not previous_proof: return False last_formula = previous_proof[-1] expected_formula_str = f"S({last_formula})" expected_code = formula_to_code.get(expected_formula_str) return expected_code == formula def is_proof_of(proof_sequence, target_formula): # Validate each line for i, formula in enumerate(proof_sequence): if is_axiom(formula): continue if not is_inference_from(proof_sequence[:i], formula): return False # Check that the proof ends in the target formula return proof_sequence[-1] == target_formula_code R(n) def R(n): def is_even(v): return v % 2 == 0 def is_odd(v): return v % 2 == 1 def greater_than_one(v): return v > 1 def return [is_even, is_odd, greater_than_one][n-1] # R(1)(4) => True, because we choose is_even, and call is_even(4) # R(2)(4) => False, because we choose is_odd, and call is_odd(4) K = [n for n in [1,2,3] if not R(n)(n)] # K => [1, 2] # R(1)(1) => 1 is not even # R(2)(2) => 2 is not odd # R(3)(3) => 3 is greater_than_one def S(n): return n in K # S(1) => True # S(3) => False'><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yingkui.com/css/dark.css><link rel=stylesheet type=text/css href=https://yingkui.com/css/custom.css><script src=https://yingkui.com/js/main.js></script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://yingkui.com/><img src=/logo-ai.jpg alt="Yingkui Lin"></a></div><h1 class=site-title><a href=https://yingkui.com/>Yingkui Lin</a></h1><div class=site-description><p>A Curious Mind.</p><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Essays</a></li><li><a href=/pages>Pages</a></li></ul></nav></div><div class=post><div class=post-header><div class=matter><h1 class=title></h1></div></div><div class=markdown><h2 id=functions-for-primes>Functions for Primes</h2><p>The following functions are normal Python functions that work with prime numbers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_divisible</span>(x, y):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> any(x <span style=color:#f92672>==</span> y <span style=color:#f92672>*</span> z <span style=color:#66d9ef>for</span> z <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_prime</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> z <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, x):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_divisible(x, z):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>nth_prime_dividing_x</span>(n, x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    primes <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> y <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_prime(y) <span style=color:#f92672>and</span> is_divisible(x, y):
</span></span><span style=display:flex><span>            primes<span style=color:#f92672>.</span>append(y)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> primes[n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> len(primes) <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>factorial</span>(n):
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        result <span style=color:#f92672>*=</span> i
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>nth_prime</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    primes <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    candidate <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> len(primes) <span style=color:#f92672>&lt;=</span> n:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_prime(candidate):
</span></span><span style=display:flex><span>            primes<span style=color:#f92672>.</span>append(candidate)
</span></span><span style=display:flex><span>        candidate <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> primes[n]
</span></span></code></pre></div><h2 id=functions-for-sequences>Functions for Sequences</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>nth_element_of_x</span>(n, x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        # Encode [2, 0, 3] → 2^2 * 3^0 * 5^3 = 4 * 1 * 125 = 500
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        x = 500
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        nth_element_of_x(0, 500) =&gt; 2  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        nth_element_of_x(1, 500) =&gt; 0  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        nth_element_of_x(2, 500) =&gt; 3  
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    base <span style=color:#f92672>=</span> nth_prime_dividing_x(n, x)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> base <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span> <span style=color:#f92672>or</span> base <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> is_divisible(x, base <span style=color:#f92672>**</span> (y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)):
</span></span><span style=display:flex><span>        y <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>len_of_elements_of_x</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        x = 500  # This encodes [2, 0, 3]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        len_of_elements_of_x(500) =&gt; 3
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> nth_prime_dividing_x(y, x) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        y <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode_sequence</span>(seq):
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(seq)):
</span></span><span style=display:flex><span>        prime <span style=color:#f92672>=</span> nth_prime(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        exponent <span style=color:#f92672>=</span> seq[i]
</span></span><span style=display:flex><span>        result <span style=color:#f92672>*=</span> prime <span style=color:#f92672>**</span> exponent
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>concat</span>(x, y):
</span></span><span style=display:flex><span>    len_x <span style=color:#f92672>=</span> len_of_elements_of_x(x)
</span></span><span style=display:flex><span>    len_y <span style=color:#f92672>=</span> len_of_elements_of_x(y)
</span></span><span style=display:flex><span>    combined <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add all elements from x</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len_x):
</span></span><span style=display:flex><span>        combined<span style=color:#f92672>.</span>append(nth_element_of_x(i, x))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Add all elements from y</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(len_y):
</span></span><span style=display:flex><span>        combined<span style=color:#f92672>.</span>append(nth_element_of_x(j, y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> encode_sequence(combined)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>convert_to_sequence</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        convert_to_sequence(3) =&gt; 8  (2^3)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        nth_element_of_x(0, convert_to_sequence(3)) =&gt; 3
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        len_of_elements_of_x(convert_to_sequence(3)) =&gt; 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>**</span> x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parens</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        x = encode_sequence([5, 7])
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        parens(x) encodes [11, 5, 7, 13]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> concat(concat(convert_to_sequence(<span style=color:#ae81ff>11</span>), x), convert_to_sequence(<span style=color:#ae81ff>13</span>))
</span></span></code></pre></div><h2 id=functions-for-sequences-1>Functions for Sequences</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_variable_of_type</span>(n, x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Checks if x is a variable of n-th type, meaning:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    x = z^n for some prime z ≥ 13
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Args:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        n: positive integer
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        x: Gödel number
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        True if x is the n-th power of some prime z ≥ 13
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> z <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>13</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_prime(z) <span style=color:#f92672>and</span> z <span style=color:#f92672>**</span> n <span style=color:#f92672>==</span> x:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_variable</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Checks if x is a variable (of any n-th type).
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        True if there exists n such that is_variable_of_type(n, x) is True.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_variable_of_type(n, x):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>negate_formula</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Negates the formula encoded by x.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    R(5) is Gödel number for the &#34;¬&#34; symbol.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Gödel encoding of [5] + parens(x)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> concat(convert_to_sequence(<span style=color:#ae81ff>5</span>), parens(x))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>disjunction</span>(x, y):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Logical disjunction of formulas x and y.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    R(7) is Gödel code for &#34;∨&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Gödel encoding of parens(x) + [7] + parens(y)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> concat(concat(parens(x), convert_to_sequence(<span style=color:#ae81ff>7</span>)), parens(y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generalize</span>(x, y):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Generalization of formula y with respect to variable x.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    R(9) is Gödel code for the ∀ quantifier.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Gödel encoding of [x] + [9] + parens(y)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> concat(concat(convert_to_sequence(x), convert_to_sequence(<span style=color:#ae81ff>9</span>)), parens(y))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>prefix_f</span>(n, x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns the result of prefixing &#39;f&#39; (Gödel code 3) n times before x.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    nth successor of x
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> concat(convert_to_sequence(<span style=color:#ae81ff>3</span>), result)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>number_sign</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns the Gödel number representing the numeral for n.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Defined as: prefix_f(n, convert_to_sequence(1))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> prefix_f(n, convert_to_sequence(<span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_first_type_symbol</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        True if x is of the form: [3, 3, ..., 3] + [m] for valid m.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        convert_to_sequence(1) = 2^1 = 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        prefix_f(2, convert_to_sequence(1)) = [3, 3] + [1] → encodes: convert_to_sequence(3), convert_to_sequence(3), convert_to_sequence(1)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        x = prefix_f(2, convert_to_sequence(1))  # ≈ 2^3 * 3^3 * 5^1 = 270
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        is_first_type_symbol(270) =&gt; True
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        # m can also be a variable of type 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        m = 13  # a prime ≥ 13, so x = 13^1 = 13 is a variable of type 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        convert_to_sequence(m) = 2^13 = 8192
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        prefix_f(1, convert_to_sequence(m)) = convert_to_sequence(3) * 8192
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        is_first_type_symbol(convert_to_sequence(3) * 8192) =&gt; True
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> m <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> m <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> is_variable_of_type(<span style=color:#ae81ff>1</span>, m):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> prefix_f(n, convert_to_sequence(m)) <span style=color:#f92672>==</span> x:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_symbol_of_type</span>(n, x):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Determines whether x is a symbol of the n-th type.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    - If n == 1: same as is_first_type_symbol(x)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    - If n &gt; 1: x must equal convert_to_sequence(v) for some v where v is a variable of type n
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Example:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        n = 1
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        x = prefix_f(1, convert_to_sequence(1)) =&gt; x = convert_to_sequence(3) * convert_to_sequence(1)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        is_symbol_of_type(1, x) =&gt; True
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        n = 2
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        v = 13  # 13 is prime ≥ 13 → variable of type 2 if x = 13^2 = 169
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        x = convert_to_sequence(169)  # =&gt; 2^169
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        is_symbol_of_type(2, 2**169) =&gt; True
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> is_first_type_symbol(x)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> v <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_variable_of_type(n, v) <span style=color:#f92672>and</span> convert_to_sequence(v) <span style=color:#f92672>==</span> x:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><h2 id=is_proof_of>is_proof_of</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_inference_from</span>(previous_proof, formula):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> previous_proof:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    last_formula <span style=color:#f92672>=</span> previous_proof[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    expected_formula_str <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;S(</span><span style=color:#e6db74>{</span>last_formula<span style=color:#e6db74>}</span><span style=color:#e6db74>)&#34;</span>
</span></span><span style=display:flex><span>    expected_code <span style=color:#f92672>=</span> formula_to_code<span style=color:#f92672>.</span>get(expected_formula_str)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> expected_code <span style=color:#f92672>==</span> formula
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_proof_of</span>(proof_sequence, target_formula):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Validate each line</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, formula <span style=color:#f92672>in</span> enumerate(proof_sequence):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_axiom(formula):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> is_inference_from(proof_sequence[:i], formula):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Check that the proof ends in the target formula</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> proof_sequence[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> target_formula_code
</span></span></code></pre></div><h2 id=rn>R(n)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>R</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_even</span>(v): 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_odd</span>(v): 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>greater_than_one</span>(v): 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>return</span> [is_even, is_odd, greater_than_one][n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># R(1)(4) =&gt; True, because we choose is_even, and call is_even(4)</span>
</span></span><span style=display:flex><span><span style=color:#75715e># R(2)(4) =&gt; False, because we choose is_odd, and call is_odd(4)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>K <span style=color:#f92672>=</span> [n <span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>] <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> R(n)(n)]
</span></span><span style=display:flex><span><span style=color:#75715e># K =&gt; [1, 2]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># R(1)(1) =&gt; 1 is not even</span>
</span></span><span style=display:flex><span><span style=color:#75715e># R(2)(2) =&gt; 2 is not odd</span>
</span></span><span style=display:flex><span><span style=color:#75715e># R(3)(3) =&gt; 3 is greater_than_one</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>S</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> n <span style=color:#f92672>in</span> K
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span><span style=color:#75715e># S(1) =&gt; True</span>
</span></span><span style=display:flex><span><span style=color:#75715e># S(3) =&gt; False</span>
</span></span></code></pre></div></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2026 © Copyright Yingkui.com All Rights Reserved</div></nav></div></body></html>