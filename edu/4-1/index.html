<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>- Yingkui</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content><meta itemprop=description content="4.1 如何解决问题？ 一般来说，很难在一开始就明确生成验收测试题的算法 $G$，但却可以找到或是想出验收测试题的样本，例如，往年的考试真题或者模拟题。如果考题缺乏变化，无非是随机抽样或者简单的更换数字或场景，那么就很容易明确生成测试题的算法，也就容易准备需要学习者掌握的元素化的知识点。但如果考试题富于变化，是某些通用性解决问题策略的考察，那么如果采用强健技术的方式，就会使得备考工作量巨大却仍有所疏漏。
这一章的目的就是，在拥有测试材料样本的情况下，如何准备元素化的教学知识点？教学者要知道如何使用恰当的办法解决这些问题。这样问题就转化成了：如何解决问题？在解决问题之前，我们要明确什么是问题，和为什么问题可以被解决？这就不得不去明确什么是思考的界限。本章将从计算学的角度逐层分析这些问题。
4.1.1 计算 这里将对计算进行讨论，这里使用图灵（1936）的模型：
可区分性：存在可以区分的不同对象，是计算最本质的基础。
可组合性：所谓组合性，就是可以把可以区分的对象放在一个可以区分前后的抽象容器当中，例如，向量或者图灵机的方格长纸条。可组合性使得我们可以通过组合可区分对象得到更多的可区分的对象。由于抽象容器中，存在空状态，这就使得，只要我们拥有一个非空状态就能得到无穷多的可区分对象。可组合性，其实就是计算对空间存在的要求。
可转化性：所谓转化性，就是可以规定把任何一个可区分的对象，转化为另外一个任何可区分的对象。可转化性，其实就是计算对时间存在的要求。转化不仅要可以转化当前可感知的符号对象，还可以在空间上去访问临近的符号对象，从而做出判断。由于每一个转化规则又是一个新的可以区分的对象，从而可以将原子化的转化规则组合起来，形成一个有次序的指令串。这样的规定可以使得，对于可以区分的对象，可以使用可区分的符号来指代，从而缩短计算量。由于转化规则中，存在一定的通用处理方案（例如，如果不是，指针向右），使得抽象对象成为可能。计算指令都是可以用一阶逻辑来表达的。
当我们对一个计算实体赋予如上足够能力时，就可以是图灵完备的。根据邱奇－图灵论题，这就是一个计算实体所需计算技能的最高上限。本文中，最核心的假设就是邱奇－图灵论题。本文作者相信，任何一个图灵完备的计算实体，例如手机和个人电脑，都具备达到人脑智力的可能，也就是相信通用人工智能的可能。
4.1.2 抽象 定义 $A$ 为某一个严格定义的算法，而 $d_r$ 是 $A$ 输出的一个可能数据，那么所有可以满足：
$$d_r == A(d_i)$$
的 $d_i$ 便是一个类。使用集合的语言表达，即是 ${d_i : A(d_i) == d_r}$
由于计算中对转化性的设置，使得计算总是决定性的，而逆运算可以有不止一个初设可能，从而形成抽象。因为我们可以定义类，也就定义了新的可以区分的概念，例如，偶数。对于这样的新概念，我们看作是某些可以元素化计算要求的简单组合，例如一些元素化判断条件的合取范式（Conjunctive Normal Form），编程语言中的类型检查就是比较容易明确的类概念。
抽象的本质就是对信息的剥离，减少对具体、明确信息的限制，得到更为通用的规律，而不是限制严格、缺乏弹性的计算结果。前文提到计算中要求有区分性，抽象就是减少可以使之被区分的部分信息。抽象使得信息传递更加简洁，使得计算结果更加通用。这些对信息的限制可以理解为特征，也可以认为是信息，也是定义中关心的限制，或者抽象对象具备的能力。
对于一个具象信息 $x$，可以隶属于无数的类，如何从这些类中选择出可以体现 $x$ 显著特征（或是在语境下的显著特征）决定着解决问题的搜索效率，例如，一般来说，对于三个苹果，最显著的特征可以是三个和苹果。 定义 为抽离特征的一个算法， 是剥离出来的显著特征集合，对于某个具象信息 ，有：
$$A_{fe}(x) == d_f$$
对于 $A_{fe}$ 的具体执行算法，这里无法展开并明确，本文中，只能去假设存在这样一个通用的算法，并且每一个智能个体（agent）由于计算经历不同所得到的显著特征不尽相同。
假设某一抽象对象 $a_i$，具备 $f_{1} \land f_2\land \cdots \land f_n$ 的显著特征。我们可以带着这些特征进行计算，得到的不一定是具体的结果，而是满足一定特征的新抽象对象 。我们称这种带着抽象进行的计算推理为抽象计算，或者是元运算。通过抽象计算，我们可以验证两个不同算法的计算等同性，也就可以验证两个不同抽象对象的抽象限制的等同性（同类）。 抽象的价值在于，如果进行了抽象级别的运算，那么一个类满足的规律对于每一个实例都满足，也就是缩短了计算量（也就是三段式）。 与此同时，抽象对象还可以隶属于更加抽象的类，同样，更为抽象的对象满足的计算结果同样适用每一个更少抽象对象，例如，$a^2-b^2 = (a-b)(a+b)\Rightarrow 14^2 -13^2 = (14-13)(14+13)\Rightarrow $ 一共十四个农场，每个农场十四只羊，其中十三个农场里每个农场卖掉了十三只羊，所有农场还剩十七个羊。"><meta itemprop=wordCount content="140"><meta itemprop=keywords content><meta property="og:title" content><meta property="og:description" content="4.1 如何解决问题？ 一般来说，很难在一开始就明确生成验收测试题的算法 $G$，但却可以找到或是想出验收测试题的样本，例如，往年的考试真题或者模拟题。如果考题缺乏变化，无非是随机抽样或者简单的更换数字或场景，那么就很容易明确生成测试题的算法，也就容易准备需要学习者掌握的元素化的知识点。但如果考试题富于变化，是某些通用性解决问题策略的考察，那么如果采用强健技术的方式，就会使得备考工作量巨大却仍有所疏漏。
这一章的目的就是，在拥有测试材料样本的情况下，如何准备元素化的教学知识点？教学者要知道如何使用恰当的办法解决这些问题。这样问题就转化成了：如何解决问题？在解决问题之前，我们要明确什么是问题，和为什么问题可以被解决？这就不得不去明确什么是思考的界限。本章将从计算学的角度逐层分析这些问题。
4.1.1 计算 这里将对计算进行讨论，这里使用图灵（1936）的模型：
可区分性：存在可以区分的不同对象，是计算最本质的基础。
可组合性：所谓组合性，就是可以把可以区分的对象放在一个可以区分前后的抽象容器当中，例如，向量或者图灵机的方格长纸条。可组合性使得我们可以通过组合可区分对象得到更多的可区分的对象。由于抽象容器中，存在空状态，这就使得，只要我们拥有一个非空状态就能得到无穷多的可区分对象。可组合性，其实就是计算对空间存在的要求。
可转化性：所谓转化性，就是可以规定把任何一个可区分的对象，转化为另外一个任何可区分的对象。可转化性，其实就是计算对时间存在的要求。转化不仅要可以转化当前可感知的符号对象，还可以在空间上去访问临近的符号对象，从而做出判断。由于每一个转化规则又是一个新的可以区分的对象，从而可以将原子化的转化规则组合起来，形成一个有次序的指令串。这样的规定可以使得，对于可以区分的对象，可以使用可区分的符号来指代，从而缩短计算量。由于转化规则中，存在一定的通用处理方案（例如，如果不是，指针向右），使得抽象对象成为可能。计算指令都是可以用一阶逻辑来表达的。
当我们对一个计算实体赋予如上足够能力时，就可以是图灵完备的。根据邱奇－图灵论题，这就是一个计算实体所需计算技能的最高上限。本文中，最核心的假设就是邱奇－图灵论题。本文作者相信，任何一个图灵完备的计算实体，例如手机和个人电脑，都具备达到人脑智力的可能，也就是相信通用人工智能的可能。
4.1.2 抽象 定义 $A$ 为某一个严格定义的算法，而 $d_r$ 是 $A$ 输出的一个可能数据，那么所有可以满足：
$$d_r == A(d_i)$$
的 $d_i$ 便是一个类。使用集合的语言表达，即是 ${d_i : A(d_i) == d_r}$
由于计算中对转化性的设置，使得计算总是决定性的，而逆运算可以有不止一个初设可能，从而形成抽象。因为我们可以定义类，也就定义了新的可以区分的概念，例如，偶数。对于这样的新概念，我们看作是某些可以元素化计算要求的简单组合，例如一些元素化判断条件的合取范式（Conjunctive Normal Form），编程语言中的类型检查就是比较容易明确的类概念。
抽象的本质就是对信息的剥离，减少对具体、明确信息的限制，得到更为通用的规律，而不是限制严格、缺乏弹性的计算结果。前文提到计算中要求有区分性，抽象就是减少可以使之被区分的部分信息。抽象使得信息传递更加简洁，使得计算结果更加通用。这些对信息的限制可以理解为特征，也可以认为是信息，也是定义中关心的限制，或者抽象对象具备的能力。
对于一个具象信息 $x$，可以隶属于无数的类，如何从这些类中选择出可以体现 $x$ 显著特征（或是在语境下的显著特征）决定着解决问题的搜索效率，例如，一般来说，对于三个苹果，最显著的特征可以是三个和苹果。 定义 为抽离特征的一个算法， 是剥离出来的显著特征集合，对于某个具象信息 ，有：
$$A_{fe}(x) == d_f$$
对于 $A_{fe}$ 的具体执行算法，这里无法展开并明确，本文中，只能去假设存在这样一个通用的算法，并且每一个智能个体（agent）由于计算经历不同所得到的显著特征不尽相同。
假设某一抽象对象 $a_i$，具备 $f_{1} \land f_2\land \cdots \land f_n$ 的显著特征。我们可以带着这些特征进行计算，得到的不一定是具体的结果，而是满足一定特征的新抽象对象 。我们称这种带着抽象进行的计算推理为抽象计算，或者是元运算。通过抽象计算，我们可以验证两个不同算法的计算等同性，也就可以验证两个不同抽象对象的抽象限制的等同性（同类）。 抽象的价值在于，如果进行了抽象级别的运算，那么一个类满足的规律对于每一个实例都满足，也就是缩短了计算量（也就是三段式）。 与此同时，抽象对象还可以隶属于更加抽象的类，同样，更为抽象的对象满足的计算结果同样适用每一个更少抽象对象，例如，$a^2-b^2 = (a-b)(a+b)\Rightarrow 14^2 -13^2 = (14-13)(14+13)\Rightarrow $ 一共十四个农场，每个农场十四只羊，其中十三个农场里每个农场卖掉了十三只羊，所有农场还剩十七个羊。"><meta property="og:type" content="article"><meta property="og:url" content="https://yingkui.com/edu/4-1/"><meta property="article:section" content="edu"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="4.1 如何解决问题？ 一般来说，很难在一开始就明确生成验收测试题的算法 $G$，但却可以找到或是想出验收测试题的样本，例如，往年的考试真题或者模拟题。如果考题缺乏变化，无非是随机抽样或者简单的更换数字或场景，那么就很容易明确生成测试题的算法，也就容易准备需要学习者掌握的元素化的知识点。但如果考试题富于变化，是某些通用性解决问题策略的考察，那么如果采用强健技术的方式，就会使得备考工作量巨大却仍有所疏漏。
这一章的目的就是，在拥有测试材料样本的情况下，如何准备元素化的教学知识点？教学者要知道如何使用恰当的办法解决这些问题。这样问题就转化成了：如何解决问题？在解决问题之前，我们要明确什么是问题，和为什么问题可以被解决？这就不得不去明确什么是思考的界限。本章将从计算学的角度逐层分析这些问题。
4.1.1 计算 这里将对计算进行讨论，这里使用图灵（1936）的模型：
可区分性：存在可以区分的不同对象，是计算最本质的基础。
可组合性：所谓组合性，就是可以把可以区分的对象放在一个可以区分前后的抽象容器当中，例如，向量或者图灵机的方格长纸条。可组合性使得我们可以通过组合可区分对象得到更多的可区分的对象。由于抽象容器中，存在空状态，这就使得，只要我们拥有一个非空状态就能得到无穷多的可区分对象。可组合性，其实就是计算对空间存在的要求。
可转化性：所谓转化性，就是可以规定把任何一个可区分的对象，转化为另外一个任何可区分的对象。可转化性，其实就是计算对时间存在的要求。转化不仅要可以转化当前可感知的符号对象，还可以在空间上去访问临近的符号对象，从而做出判断。由于每一个转化规则又是一个新的可以区分的对象，从而可以将原子化的转化规则组合起来，形成一个有次序的指令串。这样的规定可以使得，对于可以区分的对象，可以使用可区分的符号来指代，从而缩短计算量。由于转化规则中，存在一定的通用处理方案（例如，如果不是，指针向右），使得抽象对象成为可能。计算指令都是可以用一阶逻辑来表达的。
当我们对一个计算实体赋予如上足够能力时，就可以是图灵完备的。根据邱奇－图灵论题，这就是一个计算实体所需计算技能的最高上限。本文中，最核心的假设就是邱奇－图灵论题。本文作者相信，任何一个图灵完备的计算实体，例如手机和个人电脑，都具备达到人脑智力的可能，也就是相信通用人工智能的可能。
4.1.2 抽象 定义 $A$ 为某一个严格定义的算法，而 $d_r$ 是 $A$ 输出的一个可能数据，那么所有可以满足：
$$d_r == A(d_i)$$
的 $d_i$ 便是一个类。使用集合的语言表达，即是 ${d_i : A(d_i) == d_r}$
由于计算中对转化性的设置，使得计算总是决定性的，而逆运算可以有不止一个初设可能，从而形成抽象。因为我们可以定义类，也就定义了新的可以区分的概念，例如，偶数。对于这样的新概念，我们看作是某些可以元素化计算要求的简单组合，例如一些元素化判断条件的合取范式（Conjunctive Normal Form），编程语言中的类型检查就是比较容易明确的类概念。
抽象的本质就是对信息的剥离，减少对具体、明确信息的限制，得到更为通用的规律，而不是限制严格、缺乏弹性的计算结果。前文提到计算中要求有区分性，抽象就是减少可以使之被区分的部分信息。抽象使得信息传递更加简洁，使得计算结果更加通用。这些对信息的限制可以理解为特征，也可以认为是信息，也是定义中关心的限制，或者抽象对象具备的能力。
对于一个具象信息 $x$，可以隶属于无数的类，如何从这些类中选择出可以体现 $x$ 显著特征（或是在语境下的显著特征）决定着解决问题的搜索效率，例如，一般来说，对于三个苹果，最显著的特征可以是三个和苹果。 定义 为抽离特征的一个算法， 是剥离出来的显著特征集合，对于某个具象信息 ，有：
$$A_{fe}(x) == d_f$$
对于 $A_{fe}$ 的具体执行算法，这里无法展开并明确，本文中，只能去假设存在这样一个通用的算法，并且每一个智能个体（agent）由于计算经历不同所得到的显著特征不尽相同。
假设某一抽象对象 $a_i$，具备 $f_{1} \land f_2\land \cdots \land f_n$ 的显著特征。我们可以带着这些特征进行计算，得到的不一定是具体的结果，而是满足一定特征的新抽象对象 。我们称这种带着抽象进行的计算推理为抽象计算，或者是元运算。通过抽象计算，我们可以验证两个不同算法的计算等同性，也就可以验证两个不同抽象对象的抽象限制的等同性（同类）。 抽象的价值在于，如果进行了抽象级别的运算，那么一个类满足的规律对于每一个实例都满足，也就是缩短了计算量（也就是三段式）。 与此同时，抽象对象还可以隶属于更加抽象的类，同样，更为抽象的对象满足的计算结果同样适用每一个更少抽象对象，例如，$a^2-b^2 = (a-b)(a+b)\Rightarrow 14^2 -13^2 = (14-13)(14+13)\Rightarrow $ 一共十四个农场，每个农场十四只羊，其中十三个农场里每个农场卖掉了十三只羊，所有农场还剩十七个羊。"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yingkui.com/css/dark.css><link rel=stylesheet type=text/css href=https://yingkui.com/css/custom.css><script src=https://yingkui.com/js/feather.min.js></script><script src=https://yingkui.com/js/main.js></script><link rel=stylesheet href=https://yingkui.com/css/katex.min.css><script defer src=https://yingkui.com/js/katex.min.js></script><script defer src=https://yingkui.com/js/mhchem.min.js></script><script defer src=https://yingkui.com/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://yingkui.com/><img src=/logo-ai.jpg alt=Yingkui></a></div><h1 class=site-title><a href=https://yingkui.com/>Yingkui</a></h1><div class=site-description><p>Solving Problems. Making Progress.</p><nav class="nav social"><ul class=flat><li><a href=https://github.com/lin title=Github><i data-feather=github></i></a></li><li><a href=https://youtube.com/@yingkui title=YouTube><i data-feather=youtube></i></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>随想</a></li><li><a href=/edu>《教学》</a></li><li><a href=/life>《人生》</a></li><li><a href=/ai>《智力》</a></li><li><a href=/about>关于</a></li></ul></nav></div><div class=post><div class=post-header><div class=matter><h1 class=title></h1></div></div><div class=markdown><h2 id=41-如何解决问题>4.1 如何解决问题？</h2><p>一般来说，很难在一开始就明确生成验收测试题的算法 $G$，但却可以找到或是想出验收测试题的样本，例如，往年的考试真题或者模拟题。如果考题缺乏变化，无非是随机抽样或者简单的更换数字或场景，那么就很容易明确生成测试题的算法，也就容易准备需要学习者掌握的元素化的知识点。但如果考试题富于变化，是某些通用性解决问题策略的考察，那么如果采用强健技术的方式，就会使得备考工作量巨大却仍有所疏漏。</p><p>这一章的目的就是，在拥有测试材料样本的情况下，如何准备元素化的教学知识点？教学者要知道如何使用恰当的办法解决这些问题。这样问题就转化成了：如何解决问题？在解决问题之前，我们要明确什么是问题，和为什么问题可以被解决？这就不得不去明确什么是思考的界限。本章将从计算学的角度逐层分析这些问题。</p><h3 id=411-计算>4.1.1 计算</h3><p>这里将对计算进行讨论，这里使用图灵（1936）的模型：</p><ol><li><p><strong>可区分性</strong>：存在可以区分的不同对象，是计算最本质的基础。</p></li><li><p><strong>可组合性</strong>：所谓组合性，就是可以把可以区分的对象放在一个可以区分前后的抽象容器当中，例如，向量或者图灵机的方格长纸条。可组合性使得我们可以通过组合可区分对象得到更多的可区分的对象。由于抽象容器中，存在空状态，这就使得，只要我们拥有一个非空状态就能得到无穷多的可区分对象。可组合性，其实就是计算对空间存在的要求。</p></li><li><p><strong>可转化性</strong>：所谓转化性，就是可以规定把任何一个可区分的对象，转化为另外一个任何可区分的对象。可转化性，其实就是计算对时间存在的要求。转化不仅要可以转化当前可感知的符号对象，还可以在空间上去访问临近的符号对象，从而做出判断。由于每一个转化规则又是一个新的可以区分的对象，从而可以将原子化的转化规则组合起来，形成一个有次序的指令串。这样的规定可以使得，对于可以区分的对象，可以使用可区分的符号来指代，从而缩短计算量。由于转化规则中，存在一定的通用处理方案（例如，如果不是，指针向右），使得抽象对象成为可能。计算指令都是可以用一阶逻辑来表达的。</p></li></ol><p>当我们对一个计算实体赋予如上足够能力时，就可以是图灵完备的。根据邱奇－图灵论题，这就是一个计算实体所需计算技能的最高上限。本文中，最核心的假设就是邱奇－图灵论题。本文作者相信，任何一个图灵完备的计算实体，例如手机和个人电脑，都具备达到人脑智力的可能，也就是相信通用人工智能的可能。</p><h3 id=412-抽象>4.1.2 抽象</h3><p>定义 $A$ 为某一个严格定义的算法，而 $d_r$ 是 $A$ 输出的一个可能数据，那么所有可以满足：</p><p>$$d_r == A(d_i)$$</p><p>的 $d_i$ 便是一个类。使用集合的语言表达，即是 ${d_i : A(d_i) == d_r}$</p><p>由于计算中对转化性的设置，使得计算总是决定性的，而逆运算可以有不止一个初设可能，从而形成抽象。因为我们可以定义类，也就定义了新的可以区分的概念，例如，偶数。对于这样的新概念，我们看作是某些可以元素化计算要求的简单组合，例如一些元素化判断条件的合取范式（Conjunctive Normal Form），编程语言中的类型检查就是比较容易明确的类概念。</p><p>抽象的本质就是对信息的剥离，减少对具体、明确信息的限制，得到更为通用的规律，而不是限制严格、缺乏弹性的计算结果。前文提到计算中要求有区分性，抽象就是减少可以使之被区分的部分信息。抽象使得信息传递更加简洁，使得计算结果更加通用。这些对信息的限制可以理解为特征，也可以认为是信息，也是定义中关心的限制，或者抽象对象具备的能力。</p><p>对于一个具象信息 $x$，可以隶属于无数的类，如何从这些类中选择出可以体现 $x$ 显著特征（或是在语境下的显著特征）决定着解决问题的搜索效率，例如，一般来说，对于三个苹果，最显著的特征可以是三个和苹果。
定义 为抽离特征的一个算法， 是剥离出来的显著特征集合，对于某个具象信息 ，有：</p><p>$$A_{fe}(x) == d_f$$</p><p>对于 $A_{fe}$ 的具体执行算法，这里无法展开并明确，本文中，只能去假设存在这样一个通用的算法，并且每一个智能个体（agent）由于计算经历不同所得到的显著特征不尽相同。</p><p>假设某一抽象对象 $a_i$，具备 $f_{1} \land f_2\land \cdots \land f_n$ 的显著特征。我们可以带着这些特征进行计算，得到的不一定是具体的结果，而是满足一定特征的新抽象对象 。我们称这种带着抽象进行的计算推理为抽象计算，或者是元运算。通过抽象计算，我们可以验证两个不同算法的计算等同性，也就可以验证两个不同抽象对象的抽象限制的等同性（同类）。
抽象的价值在于，如果进行了抽象级别的运算，那么一个类满足的规律对于每一个实例都满足，也就是缩短了计算量（也就是三段式）。
与此同时，抽象对象还可以隶属于更加抽象的类，同样，更为抽象的对象满足的计算结果同样适用每一个更少抽象对象，例如，$a^2-b^2 = (a-b)(a+b)\Rightarrow 14^2 -13^2 = (14-13)(14+13)\Rightarrow $ 一共十四个农场，每个农场十四只羊，其中十三个农场里每个农场卖掉了十三只羊，所有农场还剩十七个羊。</p><p>抽象问题可以形成抽象层级，这使得在某个层级（可以类比成某个清晰程度）上，可以认为某两个具象对象是等同的、无法区别的，在另一个更加清晰的抽象层级上，就是不同的、可以区别的。不同的抽象层级，可以让解决问题剥离成不同的部分，也有利于得到抽象结论，减少解决问题的计算量。</p><p>无论是具象还是抽象，讨论的对象是否等同或者可以区分，是计算最本质的基础。等同意味着可以直接套用之前的计算，意味着转化和连接，意味着可以利用工具的范围扩大，意味着解决问题效率的提升。</p><p>虽然抽象比较容易通过简短的一阶逻辑来定义，但实际中，因为考虑的对象包含的信息巨大，通常特征指的是统计上的限制。</p><p>综上，对于抽象：</p><ol><li>定义：通过计算的逆运算来定义；存在抽象的抽象和不同的抽象层级</li><li>抽象运算：带着抽象对象，进行讨论运算，从而得到新的抽象对象</li><li>抽象运算结论适用于所有具象，可以缩短计算量</li><li>计算的等同性：通过抽象运算，判断两个算法功效的一致性，也可以证明抽象对象是否同类</li><li>特征抽离：抽象行为，对具象信息进行处理，剥离出有利于高效率解决问题的显著特征</li></ol><h4 id=413-解决>4.1.3 解决</h4><p>问题就是对缺失信息的遍寻，在合法计算中找到满足缺失条件的信息。因为任何自洽的组合中，都可以抹去部分信息，使得可以提出各式各样的问题。一般来说，可以理解为，提出需要满足一系列限制条件的抽象对象，然后对这个抽象对象进行一定运算后的结果（可能是直接返回对象），或者判断某个计算结果是否正确。一般来说，我们可以把限制条件解析成各个初设条件，以及需要达到的目标。然后从这些元素化的初设条件和目标出发，对题目的信息进行处理，得到新的可以区分的对象，逐步的得到目标所需的信息。
这就使得解决问题成了一个多端点的图（graph），并沿着符合计算规则的节点路径逐步展开触及到新的节点。多端点意味着因为初设条件中某个信息可以激发某个起点的出现，从而提供更多的计算结果来拓宽探索面。任何信息都可以被某个信号所激发，从而形成新的节点，故而，我们可以认为图的边有两类，一个是逻辑推理结果，一个是信号激发（因为 $T\rightarrow T$ 为真，所以逻辑推理包含了信号激发）。</p><p><strong>节点的信息类型、可以接受的节点路径以及如何选择节点路径</strong>，是讨论解决问题的关键，也是接下来讨论的基础。但详细展开超出了本文要讨论的范畴。</p><p>一般来说，当有一个对象时，这里讨论五种可以选择的节点路径：</p><ol><li>计算：基于某个算法对对象进行转化</li><li>逆计算：对象可以是某个算法的结果</li><li>抽象：剥离某些特征后，得到的某个类</li><li>具象：增添某些特征，得到一个更加具体的对象</li><li>等同对象：那些可以区分的对象，在计算上具有等同性</li></ol><p>任何一个可以被接纳的路径，都必须依据某个计算过程的结果，尤其是抽象计算。相比于公理化的逻辑系统，抽象计算可以有无穷多个公理。由于抽象的引入，公理化系统不再是单一层面的系统，而是拥有无穷个层级。</p><p>计算和抽象，为接纳某个路径提供了逻辑依据，尤其是带着抽象的运算和计算的等同性。</p><p>如果存在解决方案，任何问题的解决都可以有无数的方案，但基于实际的考虑，我们需要从中选择一个路径更短的或者是在一定可接受范围的时间内解决的，这就需要择优选择路径，尽可能的缩短计算量。</p><p>解决问题的一个基本原则就是，在没有可区分信号选择不同路径时，选择那些近距离的进行尝试，因为期望的计算量更低。例如，如果你的钱包不见了，应该先从家开始找，而不是去半个月前旅游过的城市找。</p><p>另一个原则就是在资源富裕的区域寻找或者引向这些区域，可以增加更多工具使用的概率，迅速扩大探索面。以及，营造一定的愿景，并考虑如何通过构造或转化，来引向并实现这个愿景。</p><p>无论是性质、技术还是策略，都使得我们可以利用已经事先计算过的步骤，来缩减计算。之所以更加关心计算的等效性，是因为可以认为等同的两个对象，直接能够套用彼此的计算结论，从而减少计算量。</p><p>在实际问题中，节点的信息类型一般都为有特殊限制的抽象对象，而可以接受的路径是在略高一层抽象的常用技术的执行或是结论的套用（多为抽象运算结论），选择路径的优先级一般和使用频率或强健程度有关。</p><h4 id=414-工具箱>4.1.4 工具箱</h4><p>在解决问题的过程，需要对解析出来信号进行处理（通常是转化），得到新的自洽的信息节点。如何处理信息？也就是采用什么工具去处理信息？这里罗列如下工具类别：</p><ol><li>定义和概念：使用一个可以区分的符号，对信息进行指代和折叠。解决问题时，通常把定义引用和打开。</li><li>公理、性质和定理：公理可以认为是计算的自洽初设，性质和定理是对已计算结论的套用，公理性质和定理，就是在最近距的区域进行探索搜寻，就如同城市的主干道或者地标建筑，是优先选择的常用路径。不仅因为解决问题的期望计算量降低，而且因为一般常用性质有如必经之路，事先探索就近区域为后续解决问题提供了高概率会使用到的结论和踏脚石，通过一点，打开一片。</li><li>明确算法技术：基本就是看见什么就操作什么，可以用计算机代替执行，根据假设，明确算法技术学生一定能学会。为了实用，我们把掺杂了对人来说毫无障碍的抽象定义也归为此类。例如，教学生使用软件库的API便是明确算法技术。</li><li>强策略技术：有一部分步骤依赖其他算法，但通常情况下都可以解决的技术。也就是说，有些步骤可能是解决不了的（例如，对某个函数求导），若可以解决，其他步骤是明确算法（例如，求曲线切线方程）。</li><li>弱策略技术：相对于强策略技术，可以解决的范围变得狭窄，或者包含着不太容易捕捉的抽象归纳，也就是对人来说样式识别比较困难，对学生本身抽象能力要求高。</li><li>通用策略技术：之前讨论的技术，都是针对具体的情景和领域，但存在着通用的对解决各类问题都有意义的策略，例如：<ol><li>基于工具的启发策略：为了利用上已有的技术，考虑对其变形或是换元，构造出工具；采取一定的转化，暴露出工具（化简或者变成常见形就是为了暴露工具，提高解决概率）或者是引向工具富裕的区域；营造可以利用得上工具的情景，并考虑如何连接。基于工具，可以仅仅是提高了相似性，或者提高了对称性。基于工具的思想，和波利亚在《如何解题》中提出的启发（heuristic）思想接近。</li><li>基于变量的方程策略：其实就是基于抽象指代的方程思想，一般就是采用符号化的指代，设元或者换元的复合（composite），建立方程，从而消元化简。</li><li>基于穷举的抽象策略：极端的来说，就是把可能性一一尝试的穷举思想。但一般来说，是在具象中进行观察，如果发现不了精准的答案，也可能在具象的举例中找到抽象的规律样式。可以对一个抽象概念，对某个变量的变化进行模拟。也可能是对一个具象对象，松绑一个限制，然后模拟这个变量变化所呈现的规律。</li></ol></li><li>片段化信息处理：上述的技术，一般都可以直接把问题解决。但遇到一定信号时，解决问题的算法是尝试尽可能的扩展自己的探索面，即使目标不是所选技术所指向的。通常，片段化的信息处理将看起来奇怪和不熟悉的，转化成了顺眼和熟悉的，从⽆从下⼝到可以消化，例如，已知 $A,B,C$ 三点共线可以视为 $k_{AB} = k_{BC}$，从而利用解析几何的工具。片段化信息处理，通俗来说，就是看到什么情景，应该想到什么，应该怎么处理，而不太在乎问题和其他条件限制。</li></ol><h4 id=415-如何解决>4.1.5 如何解决？</h4><p><img src=../img/solvegraph.svg alt=解决问题图示意></p><p>在对问题的解析后，得到了当下情景的条件和目标节点，作为解题者，同样有着工具库用来遴选。一般来说，解决问题的关键，在于选择什么样的路径？优先尝试哪些工具？</p><p>解题者在积累工具库时，一般都是通过实例的训练得到的，也就是对于不同的情景，可以有统计上的支撑。有一些路径优于其他的路径，就是由于熟悉和轻快，成为了膝跳反射，马上就被点亮。</p><p>每个解题者的思路不尽相同，因为他们的做题历史不同，统计也不同，看到不同的信号所得到的反馈不尽一致。但如果拥有稳定的测试材料，基本可以认为路径出现的频率分布是稳定的。</p><p>解题者当处理好题目信号，并对其抽象归类后，会触发大脑中相关区域的预备和执行，节点有如聚光灯下的戏剧演员，而相关信号是后台等候上场的其他演员，虽然看不到，但已经在待命。这些潜意识里，容易被激发的相关信息，就是解题者最优先考虑的对象，和搜寻的区域。除了潜意识外，解题者掌握的常规技巧和策略，如同常见路标，也是优先探寻的临近区域。</p><p>出于节约计算量的考虑，在没有明确信号区分时，解题者会逐步的扩大搜索范围，使用更加通用的技巧，使用更加低频的工具，增加尝试的时长。其中，由于解决问题中可以随便增加端点，在解题中，还常常要发现和生产出新的样式和技巧，这一般发生在尝试归纳中。总而言之，解决问题就是对节点信号的处理，并逐步扩大搜索范围，增加尝试空间的过程。</p><p><img src=../img/solvegraph2.svg alt=解决问题图示意></p><p>在解决问题中，存在着不可缩减的计算，也就是不总能抽象出一个样式，来缩减某些计算，只能通过直接的执行新鲜计算来完成。这也意味着验证和搜索的区别，对于一个通用性的题目，在没有信号刺激的前提下，为什么能够选择出某个对象而不是其他？也就是为什么可以迅速的搜索到恰当的实例？这也是一般教学过程中，教师容易犯得错误。如果老师看过答案给学生讲，就是在验证这个实例的计算，而没有解释如何找到实例，在什么信号下采取什么样的操作可以在新的情境下提高搜索效率。如果老师不解释这个问题，可以说问题并不是被解决，而只是被验证。这个情形下，老师只是扮演了一个更细致答案的角色，或者略高级的拍照搜题软件。</p><p>如果教学者不能抽象并传递更为通用的技能，而是经常讲解特例的题目，要么老师想把抽象和训练的责任交给了学生，要么就是觉得学生就应该采用题海战术积累大量的词汇，而题海战术可以理解为机器学习中的过度拟合，只能对少量训练数据提高准确率，但对于新的测试数据很可能会出现方差过大的问题。一般来说，信息更加简洁、特征更加凸显，更有利于学生识别、理解、掌握和记忆，本文后面会展开。</p><p>在教学过程中，因为主要是面向初学者进行测试，一般来说，题目都是可以在十分钟之内解决的，探索的空间较小，而且选择的路径在命题人看来是可以接受的常规路径。对于初学者，其解决问题的半径也随着技能的积累逐步扩大，对信息的处理也变得越加复杂和抽象。但对于高考数学这样选拔性很强的考试，要求学生在很短的时间内解决大量有难度（搜索面广）的题目，使得学生如果采用通用的策略，几乎很难在短时间内迅速找到正确的节点路径，有时一个不幸运的方向选择偏离就会消耗大量不必要的精力，而在高考数学中取得优势的考生，多是有着丰富的解题经验，对于各种信号的处理方式较为流畅娴熟，而不是对每道题都是新鲜的处理。</p><h4 id=案例技能和策略的区分>【案例】技能和策略的区分</h4><p><img src=../img/solvegraph3.svg alt=解决问题图示意简图></p><p>我们仍旧讨论题目：$a=2, A=\dfrac{\pi}{3}$，求周长最值</p><p>对于上方的几步踏脚石，每一步转化都不是一定清晰流畅的，我们知道边与角之后，可以采用的策略和转化有很多，但是变成角的形式，如果是一个必备的技能，就应该明确的对学生进行训练。如果被认为是思维的考察，就无法区分是熟悉度高还是思维能力强，如果想区分，就不能基于这些近距的题目，而是使用大量的远距的特例题目（使得刷题效率降低），那么考题就会缺乏对知识技能掌握的区分度，不能了解学习者是否对一类知识娴熟了解和熟练应用。虽然这样的题目对思维的要求高，但也只是在重复的考察弱通用策略。与其考察弱通用策略，不如让学生掌握更多必要的技能（更多学科或领域），从而更好地实现教育目的和提高训练回报率。</p><p>上述题目是一个很好的测试题目，一是促进学生熟练掌握解三角形近距技能，也能考察学生解三角形解决问题半径的大小，尤其是常见技能策略的结合应用，二是可以为学生解决远距离问题做好技能和实例准备。问题在于，在学生被问及这个问题时，TA应该做好了哪些准备工作？</p><p>解决一切问题的通用办法，The General Solution to Solve All Problems.</p></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2024 © Copyright Yingkui.com All Rights Reserved</div></nav></div><script>feather.replace()</script></body></html>