<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Gödel's Proof using Python - Yingkui Lin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Gödel's Proof using Python"><meta itemprop=description content="Goal of the Task The statement 7 is a prime number. is true and we can prove it formally using axioms and inference rules. So is the statemtents like 2209 is a square number. and 1597 is a Fibonacci number.."><meta itemprop=datePublished content="2025-06-16T00:00:00+00:00"><meta itemprop=dateModified content="2025-06-16T00:00:00+00:00"><meta itemprop=wordCount content="1757"><meta property="og:url" content="https://yingkui.com/godel/"><meta property="og:site_name" content="Yingkui Lin"><meta property="og:title" content="Gödel's Proof using Python"><meta property="og:description" content="Goal of the Task The statement 7 is a prime number. is true and we can prove it formally using axioms and inference rules. So is the statemtents like 2209 is a square number. and 1597 is a Fibonacci number.."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gödel's Proof using Python"><meta name=twitter:description content="Goal of the Task The statement 7 is a prime number. is true and we can prove it formally using axioms and inference rules. So is the statemtents like 2209 is a square number. and 1597 is a Fibonacci number.."><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yingkui.com/css/dark.css><link rel=stylesheet type=text/css href=https://yingkui.com/css/custom.css><script src=https://yingkui.com/js/main.js></script><link rel=stylesheet href=https://yingkui.com/css/katex.min.css><script defer src=https://yingkui.com/js/katex.min.js></script><script defer src=https://yingkui.com/js/mhchem.min.js></script><script defer src=https://yingkui.com/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://yingkui.com/><img src=/logo-ai.jpg alt="Yingkui Lin"></a></div><h1 class=site-title><a href=https://yingkui.com/>Yingkui Lin</a></h1><div class=site-description><p>A Curious Mind.</p><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Essays</a></li><li><a href=/micro>Microblogs</a></li><li><a href=/pages>Pages</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>16</span>
<span class=rest>Jun 2025</span></div></div><div class=matter><h1 class=title>Gödel's Proof using Python</h1></div></div><div class=markdown><style>p code{font-family:fira code,courier new,Courier,monospace;font-size:.95em;background-color:#f5f5f5;color:#c7254e;padding:.2em .4em;border-radius:4px;border:1px solid #e1e1e8;white-space:pre-wrap;word-break:break-word}</style><h2 id=goal-of-the-task>Goal of the Task</h2><p>The statement <em>7 is a prime number.</em> is true and we can prove it formally using axioms and inference rules. So is the statemtents like <em>2209 is a square number.</em> and <em>1597 is a Fibonacci number.</em>.</p><p>Gödel showed us there a type of number $\theta$ with a number $q$.</p><p><strong>$q$ is a $\theta$ number</strong>, the same as 7 is a prime number, the statement is true but we can&rsquo;t mechanically prove it from a fixed set of axioms.</p><p>The whole idea is to define the $\theta$, and find the $q$.</p><p>And the nature of this proof is that in a system without perplexity, a perplexity can be generated from the system.</p><h2 id=encoding-and-decoding>Encoding and Decoding</h2><p>If we accept the fact that programming can be mechanically done, we can encode any text into a number if we can write a python program, like following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode</span>(text):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(text<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#39;utf-8&#39;</span>)<span style=color:#f92672>.</span>hex(), <span style=color:#ae81ff>16</span>)
</span></span></code></pre></div><p>For example, <code>encode('1 + 1 = 2')</code> is <code>211178044722</code>.</p><p>The reverse action would be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decode</span>(number):
</span></span><span style=display:flex><span>    byte_count <span style=color:#f92672>=</span> (number<span style=color:#f92672>.</span>bit_length() <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>//</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> number<span style=color:#f92672>.</span>to_bytes(byte_count, <span style=color:#e6db74>&#39;big&#39;</span>)<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#39;utf-8&#39;</span>)
</span></span></code></pre></div><p>For example, <code>decode(273861846916120310563305513)</code> gives us <code>∀x(x+0=x)</code>.</p><h3 id=encoding-statements>Encoding Statements</h3><p>The statement <code>3 is a prime number</code> can be expressed a little big longer:</p>$$
\forall x (\forall y(x\times y = 3 \to
((x=1 \wedge y = 3)\vee(x = 3 \wedge y=1))))
$$<p>And the function call <code>encode('∀x(∀y(x×y=3→((x=1∧y=3)∨(x=3∧y=1))))')</code> gives us</p><p><code>34866652169611433353558731771603039911116713485514898318782071023779878676580404623913947424679492999390325956487465</code></p><h3 id=encoding-formulas>Encoding Formulas</h3><p>The statement has to return true or false. We can define a class of statements, for example, instead of stating $3$ is a prime number, we can define:</p>$$
\mathrm{isPrime}(z) = \forall x (\forall y(x\times y = z \to
((x=1 \wedge y = z)\vee(x = z \wedge y=1))))
$$<p>Replacing $3$ with $z$, we define a formula with one free varible (not associating with $\forall$ or $\exists$ ) that if you plugin a number, it will turn into a normal statement.</p><p>Such a formula with $z$ can also be encoded to a unique number:</p><p><code>2407446714671960661684017502465934769344525857188784286837374252857560807533789189320063964694640296626875411133665922890255481032586519234707017191823576884826025179701560314258408468859228381387370826090594053365359696218701174888257366313</code></p><h2 id=using-python>Using Python</h2><p>We can use python to argue the Gödel&rsquo;s proof.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_prime</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, int(n <span style=color:#f92672>**</span> <span style=color:#ae81ff>0.5</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> n <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>We can encode the function using <code>inspect</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>import</span> inspect
</span></span><span style=display:flex><span>encode(inspect<span style=color:#f92672>.</span>getsource(is_prime))
</span></span></code></pre></div><p>The the <code>is_prime</code> becomes a number</p><p><code>124563657395992973459423124433160591155887831920030510532410700710229237692588238535348680957649931630333633945462884102906156294002163749547084814365117696989779431735486222753897427000536583957527982637667016997657898994778376451044487325847968755340632532049394079266285850361205303693776904923331508559773080873577668933910894092892082469929610006297683455195730950133502010634</code></p><h3 id=encode-and-decode-in-python>Encode and Decode in Python</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>import</span> inspect
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode</span>(obj):
</span></span><span style=display:flex><span>    text <span style=color:#f92672>=</span> inspect<span style=color:#f92672>.</span>getsource(obj) <span style=color:#66d9ef>if</span> callable(obj) <span style=color:#66d9ef>else</span> str(obj)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> int(text<span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#39;utf-8&#39;</span>)<span style=color:#f92672>.</span>hex(), <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decode</span>(number):
</span></span><span style=display:flex><span>    byte_count <span style=color:#f92672>=</span> (number<span style=color:#f92672>.</span>bit_length() <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>//</span> <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>    decoded_text <span style=color:#f92672>=</span> number<span style=color:#f92672>.</span>to_bytes(byte_count, <span style=color:#e6db74>&#39;big&#39;</span>)<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#39;utf-8&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    local_scope <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        exec(decoded_text, {}, local_scope)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> value <span style=color:#f92672>in</span> local_scope<span style=color:#f92672>.</span>values():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> callable(value):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> value
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> decoded_text
</span></span></code></pre></div><h3 id=an-example>An Example</h3><p>Not every number can be decoded as a valid statement or formula. So the number that can be decoded has to be a valid one.</p><p>Similar to argument type checking in programming, the decoded mathematical stuff may not be suitable for function parameters.</p><p>The following is valid, which asks whether the number that encodes $\mathrm{isOdd}$ is a prime number or not.</p>$$
\mathrm{decode}(\mathrm{encode}(\mathrm{isPrime}(x)))(\mathrm{encode}(\mathrm{isOdd}(x)))
$$<p>In Python way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>isPrime</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, int(n <span style=color:#f92672>**</span> <span style=color:#ae81ff>0.5</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> n <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>isOdd</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> n <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>decode(encode(isPrime))(encode(isOdd))
</span></span></code></pre></div><p><code>encode(idOdd)</code> is a number <code>195036360125036444117266947858712823150716611928214970173155623117324581861098629640202</code>, which is not a prime number.</p><h2 id=the-unprovable-statement>The Unprovable Statement</h2><h3 id=checking-proofs-is-a-definable-formula>Checking proofs is a definable formula</h3><p>Gödel shows that checking a proof for a statement is an algorithm that can be run on a computer.</p><p>So if you give me a proof of Goldbach&rsquo;s conjecture, I can directly put it into a computer and wait for the computer to tell me whether this proof is valid or not. This can be decided in bounded time.</p><p>That is to say that $\mathrm{isProof}(y, x) $, where $x$ is a number that encodes a statement and $y$ is a number that encodes a proof, can be written as a formula in terms of the normal logical statement in metamathematics.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>isProof</span>(y, x):
</span></span><span style=display:flex><span>    proof_steps <span style=color:#f92672>=</span> decode(y)
</span></span><span style=display:flex><span>    target_statement <span style=color:#f92672>=</span> decode(x) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    known_facts <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> step <span style=color:#f92672>in</span> proof_steps:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isAxiom(step):
</span></span><span style=display:flex><span>            known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> isModusPonens(step, known_facts):
</span></span><span style=display:flex><span>            known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> isGeneralization(step, known_facts):
</span></span><span style=display:flex><span>            known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> isSubstitution(step, known_facts):
</span></span><span style=display:flex><span>            known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> proof_steps[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> target_statement
</span></span></code></pre></div><p>All you need to know here is that $\mathrm{isProof}(y, x)$ is a long sequence of symbols that can be precisely written down, like a python function is a long sequence of symbols that can be precisely written down. And it can be encoded as a single integer number, like a python function can be represented by a binary number.</p><p>Why is this important? Let&rsquo;s say, if something you can proof with finite steps mechanically, it seems less interesting, like checking whether 6911 is a prime number or not, it can be tedious, but not too magical. But if you can show that for every rectangle triangles, $a^2 + b^2 = c^2$, this is amazing and magical for the first you see, and find it useful as well. For those Euclidean (plane) geometry statements, every such statement ($a^2 + b^2 = c^2$) is either provable or its negation is provable from the axioms.</p><p>But for the Peano Arithmetic, something like Twin Prime Conjecture</p>$$
\forall n\;\exists p\;\bigl(n < p \;\wedge\; \mathrm{Prime}(p)\;\wedge\;\mathrm{Prime}(p + 2)\bigr)
$$<p>Or in its expanded long form:</p>$$
\forall n\;\exists p\;\exists k\;
\Bigl(
n + S(k) = p
\;\wedge\;
\bigl(2 \le p \;\wedge\;\forall a\,\forall b\,(p = a\cdot b \to (a=1\lor b=1))\bigr)
\;\wedge\;
\bigl(2 \le p + S(S(0))\;\wedge\;\forall a\,\forall b\,(p + S(S(0)) = a\cdot b \to (a=1\lor b=1))\bigr)
\Bigr)
$$<p>is interesting and we can mechanically check its correctness. We hope PA has the potential to proof this from axioms. But PA is not powerful enough.</p><h3 id=a-new-class-of-numbers>A New Class of Numbers</h3><p>Now we define a class of numbers as:</p>$$
\mathrm{isNotProvable}(x) = \neg ( \exists y\ (\mathrm{isProof}(y, x) )) \newline
$$<p>where $x$ is a number that encodes a statement and $y$ is a number that encodes a proof.</p><p>Just like prime numbers, there is a class of number called <code>isNotProvable</code> numbers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>isNotProvable</span>(x):
</span></span><span style=display:flex><span>    encoded_proof <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isProof(encoded_proof, x):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        encoded_proof <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>Now let&rsquo;s define another class of numbers:</p>$$\theta(x) = \mathrm{isNotProvable}(\text {encode} ( \text {decode} (x)(x)))$$<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>theta</span>(x):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> isNotProvable(decode(x)(x))
</span></span></code></pre></div><p>where $x$ is a number that encodes a formula with one free variable.</p><p>Let&rsquo;s call this new class of number as <code>theta</code> numbers.</p><h3 id=the-unprovable-true-statement>The Unprovable True Statement</h3><p>Since,</p>$$\mathrm{encode}(\theta(x))$$<p>is a number that encodes a formula with one free variable.</p><p>So,</p>$$\theta (\mathrm{encode}(\theta(x))) $$<p>is a valid statement which means</p><blockquote><p>The number that encodes the formula of <code>theta</code> is a <code>theta</code> number.</p></blockquote><p>This statement is true but not provable in the system.</p><p>That means given <code>encode</code>, <code>decode</code> and <code>isProof</code> are well-defined algorithms, the following programming will run forever without finding a proof.</p><p>You can argue <code>theta(encode(theta))</code> is true, but you can&rsquo;t find a proof to show its truth.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>theta</span>(x):
</span></span><span style=display:flex><span>    encoded_statement <span style=color:#f92672>=</span> decode(x)(x)
</span></span><span style=display:flex><span>    encoded_proof <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>        proof_steps <span style=color:#f92672>=</span> decode(encoded_proof)
</span></span><span style=display:flex><span>        target_statement <span style=color:#f92672>=</span> decode(encoded_statement)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        is_proof <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        known_facts <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> step <span style=color:#f92672>in</span> proof_steps:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> isAxiom(step):
</span></span><span style=display:flex><span>                known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> isModusPonens(step, known_facts):
</span></span><span style=display:flex><span>                known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> isGeneralization(step, known_facts):
</span></span><span style=display:flex><span>                known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> isSubstitution(step, known_facts):
</span></span><span style=display:flex><span>                known_facts<span style=color:#f92672>.</span>append(step)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                is_proof <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_proof <span style=color:#f92672>and</span> proof_steps[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> target_statement:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        encoded_proof <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>theta(encode(theta))
</span></span></code></pre></div><p><code>theta(133514517884384239898787351071441124097111921492735779120166497037102969969484145641870968779000743913117166577832441300605181260780458156826842166648906036311545855953400624143099223130979671362232330349195462116495111908299926176876690213743988269562025551505029849931116322610471774599440599052466809914994638128616264127245543742277556021977507387690601591646116904920664374964895430622280258990165822647831534735374775825764717668774815322548663759382929537135373165331282413673109912434355816873642554235743493213458428083144741450614559166854058253673292732126219368015250289351907851553591156047931030796923687091946678222995746274580068349884577231676267887755193312637470654331581715381927725894120266517341885672472699223131412523869898463628985119979813497557062137906319427521415683642938264606635314559946929981154764309265186187376987212461548809479487959230036826677649629847049782516492212509072837639424336974446860661416524437700037240837172557299172089831642823482470576402123156756568583437643751230122283410915735732499486772674993731951835251114990529006558812324827640759494211313474203677350236135774817484841648898477461768056240271400458125152389861276672290135747113761766967941565602892256009391494328571899597840998845146977885801547581630508406673906992080933836417975342457160791232427070563663665768072144747537826733225931590481418393210646717694437937536277163304723338782837812849085772857986585940684644856264604633877015794481977874623898180982175899053246939284650556002235506619338102747926424895515978567895419062240591159923180093272089256454200192306473204463868354314205177845176880692765007363508385032962329550838047447560659739008791102423078969725972309991404883242214550693475383626971185558781900198462266536510958909257182616206833707553694858593909753075207371560717581490781245204238763472182304675696381723036460536964977581989223380330019259771436851588334649934493086698065692007130495915799570211080575965816074)</code></p><p>If you run this line in a python program, it will run forever without halting.</p><h3 id=the-proof>The Proof</h3>$$\theta(\text{encode}(\theta(x)))$$<p>is the same as:</p>$$\mathrm{isNotProvable}(\text{encode}(\text{decode}(\text{encode}(\theta(x)))(\text{encode}(\theta(x)))))$$<p>Since $\text{decode}(\text{encode}(\theta(x)))$ means $\theta(x)$, so</p>$$
\theta(\text{encode}(\theta(x))) \leftrightarrow \mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))
$$<p>That is:</p>$$
\theta(\text{encode}(\theta(x))) \leftrightarrow \mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))
$$<p>If $\theta(\text{encode}(\theta(x)))$ returns <code>false</code>, that implies $\mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))$ returns <code>false</code>, which says it is provable, but this is a false statement. That means we have a contradiction here.</p><p>So if the system can&rsquo;t contain contradiction, $\theta(\text{encode}(\theta(x)))$ has to return <code>true</code>, that implies $\mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))$, which says it is not provable. There is a true statement you can&rsquo;t prove.</p><h2 id=reinvent-the-wheel>Reinvent the Wheel</h2><p>Since we have been familiar with those functions, let us make some convinient shortcuts:</p>$$
\begin{aligned}
\phi &= \mathrm{isNotProvable} \newline
\epsilon &= \mathrm{encode} \newline
\delta &= \mathrm{decode}
\end{aligned}
$$<p>For example the statement $\theta(\text{encode}(\theta(x)))$ can be expanded as:</p>$$
\phi(\epsilon (\delta(x)(x)))(\epsilon(\phi(\epsilon (\delta(x)(x)))))
$$<h3 id=the-starting-point>The Starting Point</h3><p>The liar paradox which states &ldquo;this statement is false&rdquo; is easily to come to mind. If we borrow this idea, we can find out our goal is to find a statement that means:</p><blockquote><p>This statement is not provable.</p></blockquote>$$ G \leftrightarrow \phi(\epsilon(G)) $$<p>And $G$ can be defined as a combination of our three well-defined functions $\phi$, $\epsilon$ and $\delta$.</p><h3 id=first-heuristic-trial>First Heuristic Trial</h3><p>Apparently, $\phi$ is a great choice, signaling something like <code>Not provable is not provable</code>. At the same time, we should make one free variable formula becomes a statement. The goto choice for the parameter apparently should be self-referenced to make it possible to push the searching area by using more tools since we only have very limited definations here. That means:</p>$$ G = \phi(\epsilon(\phi)) $$<p>but $\phi$ is a formula with one free variable, and it only accepts numbers encodes statements. Since $\epsilon(\phi)$ is a number encodes a formula with one free variable not a statement, this choice is invalid. But it gives us a hint that maybe we should use a formula with one free variable and this variable requires a number encodes a formula with one free variable.</p><h3 id=find-the-right-relation>Find the Right Relation</h3><p>Let&rsquo;s say $\rho$, and it might in a form like $\rho(x) = f(\delta(x), x)$. And also:</p>$$ \rho(\epsilon(\rho(x))) \leftrightarrow \phi(\epsilon(\rho(\epsilon(\rho(x))))) $$<p>If we want to find $\rho(x)$, there are many hints to solve this:</p><ol><li><p>we should make first $\rho$ in the right hand side disappear.</p></li><li><p>we should introduce $\epsilon(\rho(x))$, like in $f(\sin x) = \cos 2x$, we should introduce $\sin x$</p></li><li><p>we should introdue $\delta(x)$, that might indicate $\rho$ accepts a number encodes a formula with one free variable.</p></li></ol><p>We now should replace the first $\rho$ as $\delta(\epsilon(\rho(x)))$, it becomes:</p>$$ \rho(\epsilon(\rho(x))) \leftrightarrow \phi(\epsilon(\delta(\epsilon(\rho(x)))(\epsilon(\rho(x))))) $$<p>Noticing $\epsilon(\rho(x))$ is a number we plug in, so we find a suitable $\rho$:</p>$$ \rho(x) = \phi(\epsilon(\delta(x)(x)))$$<p>with the statement $G$ as:</p>$$ G = \rho(\epsilon(\rho(x))) $$<h2 id=gödels-paper>Gödel&rsquo;s Paper</h2><p>This article is an explanation for the following paragraphs in the Gödel&rsquo;s 1931 paper.</p><p><img src=../img/godel-1.png alt></p><p>The $[\text{R}(x); y]$ is defined as:</p>$$
[\text{R}(x); y]:=\text{decode}(x)(y)
$$<p>And $[\text{R}(x); x]$ is</p>$$
[\text{R}(x); x]= \text{decode}(x)(x)
$$<p>And $\overline {\text{Bew}}$ is $\text{isNotProvable}$, and $\text {S} (x)$ is same as above $\theta (x)$:</p>$$
\text{S}(x) := \text{isNotProvable}(\text{encode}([\text{R}(x); x])) \newline
$$$$
\text{S}(x) = \text{isNotProvable}(\text{encode}(\text{decode}(x)(x)))
$$<p><img src=../img/godel-2.png alt></p><p>And $\text K$ means when $n \in \text{K}$, $\text{S}(n)$ is true. The number $q$ is the Gödel number:</p>$$
q := \text{encode}(\text{S}(x))
$$<p>The unprovable statement is:</p>$$
\begin{aligned}
[\text{R}(q); q] &= \text{decode}(q)(q) \newline
& = \text{decode}(\text{encode}(\text{S}(x)))(\text{encode}(\text{S}(x))) \newline
& = \text{S}(\text{encode}(\text{S}(x)))
\end{aligned}
$$<p>It is easy to show:</p>$$
[\text{R}(q); q] = \text{isNotProvable}(\text{encode}([\text{R}(q); q]))
$$</div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2026 © Copyright Yingkui.com All Rights Reserved</div></nav></div></body></html>