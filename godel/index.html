<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Gödel's Proof - Yingkui Lin</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="Gödel's Proof"><meta itemprop=description content="Encoding and Decoding Encoding Statements The statement $1+1=2$ can be expressed using one unique number:
$$ 2^{2} \times3^{1} \times5^{3} \times7^{2} \times11^{1} \times13^{5} \times17^{2} \times19^{2} \times23^{1}. $$
The statement $\forall x(x + 0 = x)$ means for all natural number, if you add zero to it, it will give you the same number, e.g. $2 +0 = 2$, $32093+0=32093$. And this simple statement can be expressed using one unique number (extremely long number):"><meta itemprop=datePublished content="2025-06-16T00:00:00+00:00"><meta itemprop=dateModified content="2025-06-16T00:00:00+00:00"><meta itemprop=wordCount content="1197"><meta property="og:url" content="https://yingkui.com/godel/"><meta property="og:site_name" content="Yingkui Lin"><meta property="og:title" content="Gödel's Proof"><meta property="og:description" content="Encoding and Decoding Encoding Statements The statement $1+1=2$ can be expressed using one unique number:
$$ 2^{2} \times3^{1} \times5^{3} \times7^{2} \times11^{1} \times13^{5} \times17^{2} \times19^{2} \times23^{1}. $$
The statement $\forall x(x + 0 = x)$ means for all natural number, if you add zero to it, it will give you the same number, e.g. $2 +0 = 2$, $32093+0=32093$. And this simple statement can be expressed using one unique number (extremely long number):"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gödel's Proof"><meta name=twitter:description content="Encoding and Decoding Encoding Statements The statement $1+1=2$ can be expressed using one unique number:
$$ 2^{2} \times3^{1} \times5^{3} \times7^{2} \times11^{1} \times13^{5} \times17^{2} \times19^{2} \times23^{1}. $$
The statement $\forall x(x + 0 = x)$ means for all natural number, if you add zero to it, it will give you the same number, e.g. $2 +0 = 2$, $32093+0=32093$. And this simple statement can be expressed using one unique number (extremely long number):"><link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://yingkui.com/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://yingkui.com/css/dark.css><link rel=stylesheet type=text/css href=https://yingkui.com/css/custom.css><script src=https://yingkui.com/js/main.js></script><link rel=stylesheet href=https://yingkui.com/css/katex.min.css><script defer src=https://yingkui.com/js/katex.min.js></script><script defer src=https://yingkui.com/js/mhchem.min.js></script><script defer src=https://yingkui.com/js/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><div class="container wrapper"><div class=header><div class=avatar><a href=https://yingkui.com/><img src=/logo-ai.jpg alt="Yingkui Lin"></a></div><h1 class=site-title><a href=https://yingkui.com/>Yingkui Lin</a></h1><div class=site-description><p>A Curious Mind.</p><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Essays</a></li><li><a href=/pages>Pages</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>16</span>
<span class=rest>Jun 2025</span></div></div><div class=matter><h1 class=title>Gödel's Proof</h1></div></div><div class=markdown><style>p code{font-family:fira code,courier new,Courier,monospace;font-size:.95em;background-color:#f5f5f5;color:#c7254e;padding:.2em .4em;border-radius:4px;border:1px solid #e1e1e8;white-space:pre-wrap;word-break:break-word}</style><h2 id=encoding-and-decoding>Encoding and Decoding</h2><h3 id=encoding-statements>Encoding Statements</h3><p>The statement $1+1=2$ can be expressed using one unique number:</p><p>$$
2^{2}
\times3^{1}
\times5^{3}
\times7^{2}
\times11^{1}
\times13^{5}
\times17^{2}
\times19^{2}
\times23^{1}.
$$</p><p>The statement $\forall x(x + 0 = x)$ means for all natural number, if you add zero to it, it will give you the same number, e.g. $2 +0 = 2$, $32093+0=32093$. And this simple statement can be expressed using one unique number (extremely long number):</p><p>$$
2^{8}\times
3^{12}\times
5^{10}\times
7^{12}\times
11^{3}\times
13^{1}\times
17^{5}\times
19^{12}\times
23^{11}
$$</p><p>The statement $3$ is a prime number can be expressed a little big longer:</p><p>$$
\forall x (\forall y(x\times y = 3 \to
((x=1 \wedge y = 3)\vee(x = 3 \wedge y=1))))
$$</p><p>The encoded number will also be long:</p><p>$$
\begin{aligned}
2^{8}\times3^{12}\times5^{10}\times7^{8}\times11^{13}\times13^{10}\times17^{12}\times \newline
19^{4} \times23^{13}\times29^{5}\times31^{2}\times37^{2}\times41^{2}\times43^{1}\times \newline
47^{15}\times53^{10}\times59^{10}\times61^{12}\times67^{5}\times71^{2}\times73^{1}\times \newline
79^{14}\times83^{13}\times89^{5}\times97^{2}\times101^{2}\times103^{2}\times107^{1} \times \newline 109^{11}\times
113^{7}\times127^{10}\times131^{12}\times137^{5}\times139^{2}\times \newline 149^{2}\times151^{2}\times
157^{1}\times163^{14}\times167^{13}\times173^{5}\times \newline 179^{2}\times181^{1}\times191^{11}\times193^{11}\times197^{11}\times199^{11}
\end{aligned}
$$</p><p>Yet it is still a unique number for that statement.</p><p>Statements are also called sentences.</p><h3 id=encoding-formulas>Encoding Formulas</h3><p>The statement has to return true or false. We can define a class of statements, for example, instead of stating $3$ is a prime number, we can define:</p><p>$$
\mathrm{isPrime}(z) = \forall x (\forall y(x\times y = z \to
((x=1 \wedge y = z)\vee(x = z \wedge y=1))))
$$</p><p>Replacing $3$ with $z$, we define a formula with one free varible (not associating with $\forall$ or $\exists$ ) that if you plugin a number, it will turn into a normal statement.</p><p>Such a formula with $z$ can also be encoded to a unique number:</p><p>$$
\begin{aligned}
2^{8}
\times3^{12}
\times5^{10}
\times7^{8}
\times11^{13}
\times13^{10}\newline
\times17^{12}
\times19^{4}
\times23^{13}
\times29^{5}
\times31^{14}\newline
\times37^{16}
\times41^{10}
\times43^{10}
\times47^{12}
\times53^{5}\newline
\times59^{2}
\times61^{1}
\times67^{15}
\times71^{13}
\times73^{5}\newline
\times79^{14}
\times83^{11}
\times89^{7}
\times97^{10}
\times101^{12}\newline
\times103^{5}
\times107^{14}
\times109^{15}
\times113^{13}
\times127^{5}\newline
\times131^{2}
\times137^{1}
\times139^{11}
\times149^{11}
\times151^{11}
\times157^{11}
\end{aligned}
$$</p><p>Anothe example is the class of odd numbers:</p><p>$$
\mathrm{isOdd}(x)=\exists y(x = (y + y) + 1)
$$</p><p>The encoded number for this formula is:</p><p>$$
\begin{aligned}
2^{9}\times
3^{13}\times
5^{10}\times
7^{12}\times
11^{5}\times
13^{10}\newline\times
17^{13}\times
19^{3}\times
23^{13}\times
29^{11}\times
31^{3}\newline\times
37^{2}\times
41^{1}\times
43^{11}
\end{aligned}
$$</p><h3 id=decoding>Decoding</h3><p>Not every number can be decoded as a valid statement or formula, for example, $118098 = 2^1\times 3^{10}$ means $0=$, which has no real value to us. So the number that can be decoded has to be a valid one.</p><p>Similar to argument type checking in programming, the decoded mathematical stuff may not be suitable for function parameters.</p><p>The following is valid, which asks whether the number that encodes $\mathrm{isOdd}$ is a prime number or not.</p><p>$$
\mathrm{decode}(\mathrm{encode}(\mathrm{isPrime}(x)))(\mathrm{encode}(\mathrm{isOdd}(x)))
$$</p><p>But this one is not valid, after decoding, the statement can&rsquo;t use as a function.</p><p>$$
\mathrm{decode}(\mathrm{encode}(\forall x(x + 0 = x))(\mathrm{encode}(\mathrm{isOdd}(x)))
$$</p><p>In the coming arguments, Gödel never used an invalid number when decoding presents.</p><h2 id=the-unprovable-statement>The Unprovable Statement</h2><h3 id=checking-proofs-is-an-algorithm>Checking proofs is an algorithm</h3><p>Gödel shows that checking a proof for a statement is an algorithm that can be run on a computer.</p><p>So if you give me a proof of Goldbach&rsquo;s conjecture, I can directly put it into a computer and wait for the computer to tell me whether this proof is valid or not. This can be decided in bounded time.</p><p>And each proof can be encoded as a Gödel number as well.</p><h3 id=a-new-class-of-numbers>A New Class of Numbers</h3><p>Now we define a class of numbers as:</p><p>$$
\mathrm{isNotProvable}(x) = \neg ( \exists y\ (\mathrm{isProof}(y, x) )) \newline
$$</p><p>where $x$ is a number that encodes a statement and $y$ is a number that encodes a proof.</p><p>Just like prime numbers, there is a class of number called <code>isNotProvable</code> numbers.</p><p>Now let&rsquo;s define another class of numbers:</p><p>$$\theta(x) = \mathrm{isNotProvable}(\text {encode} ( \text {decode} (x)(x)))$$</p><p>where $x$ is a number that encodes a formula with one free variable.</p><p>Let&rsquo;s call this new class of number as <code>theta</code> numbers.</p><h3 id=the-unprovable-true-statement>The Unprovable True Statement</h3><p>Since,</p><p>$$\mathrm{encode}(\theta(x))$$</p><p>is a number that encodes a formula with one free variable.</p><p>So,</p><p>$$\theta (\mathrm{encode}(\theta(x))) $$</p><p>is a valid statement which means</p><blockquote><p>The number that encodes the formula of <code>theta</code> is a <code>theta</code> number.</p></blockquote><p>This statement is true but not provable in the system.</p><p>That means given <code>encode</code>, <code>decode</code> and <code>isProof</code> are well-defined algorithms, the following programming will run forever without finding a proof.</p><p>You can argue <code>theta(encode(theta))</code> is true, but you can&rsquo;t find a proof to show its truth.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>theta</span>(x):
</span></span><span style=display:flex><span>    formula <span style=color:#f92672>=</span> decode(x)
</span></span><span style=display:flex><span>    statement <span style=color:#f92672>=</span> formula(x)
</span></span><span style=display:flex><span>    encoded_proof <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> true:
</span></span><span style=display:flex><span>      proof <span style=color:#f92672>=</span> decode(encoded_proof)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> isProof(proof, statement):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true
</span></span><span style=display:flex><span>      encoded_proof <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>theta(encode(theta))
</span></span></code></pre></div><h3 id=the-proof>The Proof</h3><p>$$\theta(\text{encode}(\theta(x)))$$</p><p>is the same as:</p><p>$$\mathrm{isNotProvable}(\text{encode}(\text{decode}(\text{encode}(\theta(x)))(\text{encode}(\theta(x)))))$$</p><p>Since $\text{decode}(\text{encode}(\theta(x)))$ means $\theta(x)$, so</p><p>$$
\theta(\text{encode}(\theta(x))) \leftrightarrow \mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))
$$</p><p>That is:</p><p>$$
\theta(\text{encode}(\theta(x))) \leftrightarrow \mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))
$$</p><p>If $\theta(\text{encode}(\theta(x)))$ returns <code>false</code>, that implies $\mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))$ returns <code>false</code>, which says it is provable, but this is a false statement. That means we have a contradiction here.</p><p>So if the system can&rsquo;t contain contradiction, $\theta(\text{encode}(\theta(x)))$ has to return <code>true</code>, that implies $\mathrm{isNotProvable}(\text{encode}(\theta(\text{encode}(\theta(x)))))$, which says it is not provable. There is a true statement you can&rsquo;t prove.</p><h2 id=reinvent-the-wheel>Reinvent the Wheel</h2><p>Since we have been familiar with those functions, let us make some convinient shortcuts:</p><p>$$
\begin{aligned}
\phi &= \mathrm{isNotProvable} \newline
\epsilon &= \mathrm{encode} \newline
\delta &= \mathrm{decode}
\end{aligned}
$$</p><p>For example the statement $\theta(\text{encode}(\theta(x)))$ can be expanded as:</p><p>$$
\phi(\epsilon (\delta(x)(x)))(\epsilon(\phi(\epsilon (\delta(x)(x)))))
$$</p><h3 id=the-starting-point>The Starting Point</h3><p>The liar paradox which states &ldquo;this statement is false&rdquo; is easily to come to mind. If we borrow this idea, we can find out our goal is to find a statement that means:</p><blockquote><p>This statement is not provable.</p></blockquote><p>$$ G \leftrightarrow \phi(\epsilon(G)) $$</p><p>And $G$ can be defined as a combination of our three well-defined functions $\phi$, $\epsilon$ and $\delta$.</p><h3 id=first-heuristic-trial>First Heuristic Trial</h3><p>Apparently, $\phi$ is a great choice, signaling something like <code>Not provable is not provable</code>. At the same time, we should make one free variable formula becomes a statement. The goto choice for the parameter apparently should be self-referenced to make it possible to push the searching area by using more tools since we only have very limited definations here. That means:</p><p>$$ G = \phi(\epsilon(\phi)) $$</p><p>but $\phi$ is a formula with one free variable, and it only accepts numbers encodes statements. Since $\epsilon(\phi)$ is a number encodes a formula with one free variable not a statement, this choice is invalid. But it gives us a hint that maybe we should use a formula with one free variable and this variable requires a number encodes a formula with one free variable.</p><h3 id=find-the-right-relation>Find the Right Relation</h3><p>Let&rsquo;s say $\rho$, and it might in a form like $\rho(x) = f(\delta(x), x)$. And also:</p><p>$$ \rho(\epsilon(\rho(x))) \leftrightarrow \phi(\epsilon(\rho(\epsilon(\rho(x))))) $$</p><p>If we want to find $\rho(x)$, there are many hints to solve this:</p><ol><li><p>we should make first $\rho$ in the right hand side disappear.</p></li><li><p>we should introduce $\epsilon(\rho(x))$, like in $f(\sin x) = \cos 2x$, we should introduce $\sin x$</p></li><li><p>we should introdue $\delta(x)$, that might indicate $\rho$ accepts a number encodes a formula with one free variable.</p></li></ol><p>We now should replace the first $\rho$ as $\delta(\epsilon(\rho(x)))$, it becomes:</p><p>$$ \rho(\epsilon(\rho(x))) \leftrightarrow \phi(\epsilon(\delta(\epsilon(\rho(x)))(\epsilon(\rho(x))))) $$</p><p>Noticing $\epsilon(\rho(x))$ is a number we plug in, so we find a suitable $\rho$:</p><p>$$ \rho(x) = \phi(\epsilon(\delta(x)(x)))$$</p><p>with the statement $G$ as:</p><p>$$ G = \rho(\epsilon(\rho(x))) $$</p><h3 id=make-phi-and-epsilon-and-delta-precise>Make $\phi$ and $\epsilon$ and $\delta$ Precise</h3><p>TODO</p></div><div class=tags></div></div></div><div class="footer wrapper"><nav class=nav><div>2025 © Copyright Yingkui.com All Rights Reserved</div></nav></div></body></html>